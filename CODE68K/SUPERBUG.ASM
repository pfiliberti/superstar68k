	TITLE	SUPERBUG MONITOR VER 1.0 FOR SUPERSTAR MOTHERBOARD
	PW	80

********************************************************
* 68K SUPERBUG MONITOR FOR THE SUPERSTAR BOARD
*
********************************************************

* MOD 10-26-86 TO INCLUDE WINCHESTER BOOT COMMAND
* MOD 2-5-87 TO FIX ADDRESS OF FORMAT ERROR VECTOR AND
*    PROPERLY SET UP STACK FRAME
* MOD >>A<< 3-27-87 TO SLOW DOWN 1772 STEP RATE, ALLOW
*    LOWER CASE COMMANDS, RETRY WD BOOT IF IT FAILS
* MOD >>B<< 4-15-87 TO CORRECT STACK FRAME ERROR AND ALLOW
*    LOWER CASE HEX LETTERS
* MOD >>C<< 4-19-87 TO ALLOW LOWER CASE ALSO IN RC COMMAND
*    AND ALLOW 19200 BAUD AUTO-SENSE
* MOD >>D<< 5-16-87 TO FIX PROBLEMS WITH PAUSE AND PORT P
* MINOR MOD 6-26-87 TO REDUCE STARTUP TIME
* MOD >>E<< 6-30-87 TO RESTORE INTERRUPTS AFTER SS/BR
* MOD >>F<< 7-12-87 TO ALLOW LOWER CASE AFTER ^S

* EQUATES

	  GLOBAL    INCHE0

ROM	  EQU $0		   CHANGE TO $80500 FOR DEBUG IN RAM
RAM	  EQU $80000
MSTACK	  EQU RAM+$400		   EVENTUALLY $0800 MON STACK
USTACK	  EQU RAM+$300		   EVENTUALLY $0700 USER STACK
SSTACK	  EQU RAM+$200		   EVENTUALLY $0600 SYSTEM STACK

* DATA STORAGE

	  DATA
	  ORG RAM

PORADM	  BLKL 1 CONTROL PORT
PORADP	  BLKL 1 PRINTER PORT
DVECTR	  BLKL 1 USER PORT X VECTOR
PORECH	  BLKB 1 ECHO IS <> 0
REGERS	  BLKL 15 A AND D REGISTER STORAGE
REGA7	  BLKL 1 REGISTER A7
USERPC	  BLKL 1 USER PROGRAM COUNTER
USERSR	  BLKW 1 USER STATUS REGISTER
SYSTSR	  BLKW 1 SYSTEM SR DURING TRACING/BREAKPOINTS >>E<<
USERSP	  BLKL 1 USER STACK POINTER
SYSTSP	  BLKL 1 SYSTEM STACK POINTER
TRAVEC	  BLKL 1 TRACE VECTOR TEMPORARY
BKTAB	  BLKL 6 BP TABLE (LOC1, OP1,...
STATUS	  BLKB 1 STATUS: P0,P1,VID,PD,PA,X,X,X
INZFLG	  BLKL 1 PREVIOUSLY INITIALIZED FLAG
PAUCTR	  BLKB 1 PAUSE FEATURE LINE COUNTER
BEGA	  BLKL 1 BEGINNING ADDRESS
ENDA	  BLKL 1 ENDING ADDRESS
SP	  BLKL 1 STACK PTR
FINDNO	  BLKB 1 NUMBER OF BYTES IN FI
WHAT	  BLKB 5 WHAT TO FIND IN FI
NEWLOC	  BLKL 1 USED IN MO
TRP15V	  BLKW 3 JMP INSTRUCTION TO TRAP 15 HANDLER
BUSERV	  BLKW 3 JMP INSTRUCTION TO BUSERR HANDLER
TRACEV	  BLKW 3 JMP INSTRUCTION TO TRACE  HANLDER
*
* FOLLOWING IS IRQ VECTOR JUMP TABLE
*
L1IRQ	  BLKW 3 JMP INSTRUCTION TO LEVEL 1 IRQ HANDLER
L2IRQ	  BLKW 3 JMP INSTRUCTION TO LEVEL 2 IRQ HANDLER
L3IRQ	  BLKW 3 JMP INSTRUCTION TO LEVEL 3 IRQ HANDLER
L4IRQ	  BLKW 3 JMP INSTRUCTION TO LEVEL 4 IRQ HANDLER
L5IRQ	  BLKW 3 JMP INSTRUCTION TO LEVEL 5 IRQ HANDLER
L6IRQ	  BLKW 3 JMP INSTRUCTION TO LEVEL 6 IRQ HANDLER
L7IRQ	  BLKW 3 JMP INSTRUCTION TO LEVEL 7 IRQ HANDLER
;TRP0	   BLKW 3 JMP INSTRUCTION TO TRAP 0 HANDLER
;TRP1	   BLKW 3 JMP INSTRUCTION TO TRAP 1 HANDLER
;TRP2	   BLKW 3 JMP INSTRUCTION TO TRAP 2 HANDLER
;TRP3	   BLKW 3 JMP INSTRUCTION TO TRAP 3 HANDLER
;TRP4	   BLKW 3 JMP INSTRUCTION TO TRAP 4 HANDLER
;TRP5	   BLKW 3 JMP INSTRUCTION TO TRAP 5 HANDLER
;TRP6	   BLKW 3 JMP INSTRUCTION TO TRAP 6 HANDLER
;TRP7	   BLKW 3 JMP INSTRUCTION TO TRAP 7 HANDLER
;TRP8	   BLKW 3 JMP INSTRUCTION TO TRAP 8 HANDLER
;TRP9	   BLKW 3 JMP INSTRUCTION TO TRAP 9 HANDLER
;TRP10	   BLKW 3 JMP INSTRUCTION TO TRAP 10 HANDLER
;TRP11	   BLKW 3 JMP INSTRUCTION TO TRAP 11 HANDLER
;TRP12	   BLKW 3 JMP INSTRUCTION TO TRAP 12 HANDLER
;TRP13	   BLKW 3 JMP INSTRUCTION TO TRAP 13 HANDLER
;TRP14	   BLKW 3 JMP INSTRUCTION TO TRAP 14 HANDLER

* PROGRAM BEGINNING

	  CODE
	  ORG ROM

********************************************************
* VECTORS TO GO AT THE BEGINNING OF MEMORY
********************************************************

VECTRS LONG MSTACK-6		 0 INITIAL SUPERVISOR STACK POINTER
       LONG COLDST		 4 RESET VECTOR
       LONG BUSERV		 8 BUS ERROR
       LONG ADDERR		 C ADDRESS ERROR
       LONG ILLINS		10 ILLEGAL INSTRUCTION
       LONG ZERDIV		14 ZERO DIVIDE
       LONG CHKINS		18 CHK INSTRUCTION
       LONG TRAPVI		1C TRAPV INSTR
       LONG PRIVIO		20 PRIVILEGE VIOLATION
       LONG TRACEV		24 TRACE
       LONG LN1010		28 LINE 1010
       LONG LN1111		2C LINE 1111
       LONG UNASSI		30 UNASSIGNED
       LONG UNASSI		34 "
       LONG FORERR		38 FORMAT ERROR ON 68010/20
       LONG UNASSI		3C UNASSIGNED
       LONG UNASSI		40 "
       LONG UNASSI		44 "
       LONG UNASSI		48 "
       LONG UNASSI		4C "
       LONG UNASSI		50 "
       LONG UNASSI		   "
       LONG UNASSI		   "
       LONG UNASSI		   "
       LONG SPURIO		60 SPURIOUS INTERRUPT
       LONG L1IRQ		   LEVEL 1 INTERRUPT AUTOVECTOR
       LONG L2IRQ		   LEVEL 2 "
       LONG L3IRQ		   LEVEL 3 "
       LONG L4IRQ		70 LEVEL 4 "
       LONG L5IRQ		   LEVEL 5 "
       LONG L6IRQ		   LEVEL 6 "
       LONG L7IRQ		   LEVEL 7 "
       LONG TRAP0V		80 TRAP 0
       LONG TRAP1V		   TRAP 1
       LONG TRAP2V		   TRAP 2
       LONG TRAP3V		   TRAP 3
       LONG TRAP4V		90 TRAP 4
       LONG TRAP5V		   TRAP 5
       LONG TRAP6V		   TRAP 6
       LONG TRAP7V		   TRAP 7
       LONG TRAP8V		A0 TRAP 8
       LONG TRAP9V		   TRAP 9
       LONG TRAPAV		   TRAP 10
       LONG TRAPBV		   TRAP 11
       LONG TRAPCV		B0 TRAP 12
       LONG TRAPDV		   TRAP 13
       LONG TRAPEV		   TRAP 14
       LONG TRP15V		   TRAP 15 GO TO MONITOR

*******************************************************
* ENTRY POINT JUMP TABLE
*******************************************************

	DEFW	$4EF9		;LONG JUMP INSTRUCTION
	LONG	COLDST
	DEFW	$4EF9		;LONG JUMP INSTRUCTION
	LONG	WARMST
	DEFW	$4EF9		;LONG JUMP INSTRUCTION
	LONG	INEEE
	DEFW	$4EF9		;LONG JUMP INSTRUCTION
	LONG	INCH7
	DEFW	$4EF9		;LONG JUMP INSTRUCTION
	LONG	INCH8
	DEFW	$4EF9		;LONG JUMP INSTRUCTION
	LONG	OUTEEE
	DEFW	$4EF9		;LONG JUMP INSTRUCTION
	LONG	OUTCHM
	DEFW	$4EF9		;LONG JUMP INSTRUCTION
	LONG	OUTCHP
	DEFW	$4EF9		;LONG JUMP INSTRUCTION
	LONG	PSTRNG
	DEFW	$4EF9		;LONG JUMP INSTRUCTION
	LONG	OUT4HS
	DEFW	$4EF9		;LONG JUMP INSTRUCTION
	LONG	OUT8HS

*******************************************************
* IRQ & TRAP VECTOR TABLES
*******************************************************

;IRQVEC  LONG LVL1IA		     LEVEL 1 INTERRUPT AUTOVECTOR
;	 LONG LVL2IA		     LEVEL 2 "
;	 LONG LVL3IA		     LEVEL 3 "
;	 LONG LVL4IA		  70 LEVEL 4 "
;	 LONG LVL5IA		     LEVEL 5 "
;	 LONG LVL6IA		     LEVEL 6 "
;	 LONG LVL7IA		     LEVEL 7 "
;	 LONG TRAP0V		  80 TRAP 0
;	 LONG TRAP1V		     TRAP 1
;	 LONG TRAP2V		     TRAP 2
;	 LONG TRAP3V		     TRAP 3
;	 LONG TRAP4V		  90 TRAP 4
;	 LONG TRAP5V		     TRAP 5
;	 LONG TRAP6V		     TRAP 6
;	 LONG TRAP7V		     TRAP 7
;	 LONG TRAP8V		  A0 TRAP 8
;	 LONG TRAP9V		     TRAP 9
;	 LONG TRAPAV		     TRAP 10
;	 LONG TRAPBV		     TRAP 11
;	 LONG TRAPCV		  B0 TRAP 12
;	 LONG TRAPDV		     TRAP 13
;	 LONG TRAPEV		     TRAP 14

*******************************************************
* INITIAL COLD START ROUTINE.
*******************************************************

* FIRST CHECK WHETHER THIS IS INITIAL POWER UP

COLDST	  MOVEM.L D0-D0/A0-A0,-(A7) TEMP SAVE D0 AND A1
	  MOVE	  #$4EF9,D0	    D0 IS JUMP INSTRUCTION
	  MOVE	  D0,TRP15V	    INIT TRAP 15 VECTOR
	  MOVE	  D0,BUSERV	    INIT BUS ERROR VECTOR
	  MOVE	  D0,TRACEV	    INIT TRACE VECTOR
	  LEA WARMST,A1
	  MOVE.L A1,TRP15V+2	   PUT IN NEW TRAP 15 VECTOR
	  LEA BUSERR,A1
	  MOVE.L A1,BUSERV+2	   PUT IN NEW BUS ERROR VECTOR
	  LEA TRARET,A1
	  MOVE.L A1,TRACEV+2	   PUT IN NEW TRACE VECTOR
	  MOVE.L INZFLG,D0	   IS IT INITIALIZED?
	  CMP.L #$AA5555AA,D0
	  MOVEM.L (A7)+,D0-D0/A1-A1 RESTORE D0 AND A1
	  MOVEM.L D0-D7/A0-A6,REGERS PUSH ALL REGISTERS
	  BNE.S COLD1		   IF NO, DO EVERYTHING
;	  BSR	INIPOR		   ELSE INITIALIZE PORTS
	  BRA	RESET		   AND JUST RESTART HUMBUG

* ON A REAL COLD START, INITIALIZE PORTS, PARITY MEMORY,
* SET USER STACK POINTER AND USER REGISTERS

COLD1	  BSR	INIPOR		   INITIALIZE PORTS
	  BSR	MEMRD		   READ ALL OF MEMORY
	  MOVE.L #USTACK-4,A0
	  MOVE.L A0,USP 	   INITIALIZE USER STACK POINTER
	  MOVE.L #REGERS,A0	   POINT TO REGISTER STORAGE
	  MOVE.B #8,D1		   COUNTER
	  MOVE.L #$D0,D0
DLOOP	  MOVE.L D0,(A0)+	   SET DATA REGISTERS
	  ADD.B #1,D0
	  SUB.B #1,D1		   DECR COUNTER
	  BNE.S DLOOP
	  MOVE.B #7,D1		   COUNTER AGAIN
	  MOVE.L #$A0,D0
ALOOP	  MOVE.L D0,(A0)+	   SET ADDRESS REGISTERS
	  ADD.B #1,D0
	  SUB.B #1,D1		   DECR COUNTER
	  BNE.S ALOOP
	  MOVE.L #USTACK-4,(A0)+   A7=USER STACK POINTER
	  MOVE.L #WARMST,(A0)+	   PS=DEFAULT TO WARMSTART
	  MOVE.W #$0000,(A0)+	   SR=USER STATUS REGISTER
	  MOVE.L #USTACK-4,(A0)+   US=USER STACK POINTER
	  MOVE.L #USTACK-4,(A0)    SS=SYST STACK POINTER

* ERASE BREAKPOINT TABLE

RESTRT	  LEA BKTAB,A0		   NOW ERASE BRK TABLE
	  MOVE.B #$FF,D0	   FILL WITH FF'S
	  MOVE.B #24,D1 	   24 BYTES IN TABLE
BKERAS	  MOVE.B D0,(A0)+	   ERASE BREAKPOINT TABLE
	  SUB.B #01,D1
	  BNE.S BKERAS		   REPEAT IF NOT FINISHED

RESET	  MOVE.L #RTSAD,DVECTR	   POINT D VECTOR TO AN RTS
	  TRAP #15		   GO TO SUPERVISOR AND WARMST
RTSAD	  RTS

*******************************************************
* WARMSTART INITIALIZATION
*******************************************************

WARMST	  MOVE.L #MSTACK-6,A7	   SET STACK PTR TO MON AREA
	  EOR.W #$1000,SR	   FLIP TO OTHER SSR
	  MOVE.L #MSTACK-6,A7	   SET OTHER STACK POINTER TOO
	  EOR.W #$1000,SR	   RETURN TO ORIG SSR
	  BSR	PARON		   TURN ON PARITY MEMORY

;	   MOVEM.L D0-D0/A0-A1,-(A7) TEMP SAVE D0 AND A0-A1
;	   LEA	   IRQVEC,A0	     POINT A0 TO IRQ & TRAP VECTORS
;	   LEA	   L1IRQ,A1	     POINT A1 TO IRQ & TRAP JUMP TABLE
;	   MOVE    #21,D0	     INIT IRQ VECTOR JUMP TABLE
;VECINIT   MOVE    #$4EF9,(A1)+      PUT IN JUMP INSTRUCTION
;	   MOVE.L  (A0)+,(A1)+	     PUT IN JUMP ADDRESS
;	   DBRA    D0,VECINIT	     LOOP FOR ALL VECTORS
;	   MOVEM.L (A7)+,D0-D0/A0-A1 RESTORE D0 AND A0-A1
;
	  MOVE.L TRP15V+2,A0	   TEMP SAVE TRAP 15 VECTOR
	  LEA WARMS1(PC),A1
	  MOVE.L A1,TRP15V+2	   PUT IN NEW VECTOR
	  TRAP #15		   FORCE SUPERVISOR STATE
;
WARMS1	  OR.W #$0700,SR	   DISABLE INTERRUPTS
	  MOVE.W SR,SYSTSR	   AND SAVE IT
	  MOVE.L A0,TRP15V+2	   RESTORE TRAP 15 VECTOR
	  MOVE.L #MSTACK-6,A7	   SET STACK PTR TO MON AREA
	  MOVE.B #$40,STATUS	   PORT P, D, PAUSE OFF; 1 ON
	  MOVE.B #$0F,PAUCTR	   INIT PAUSE LINE COUNTER
	  MOVE.B #$FF,PORECH	   CTRL PORT ECHO ON
	  CLR.L D0
	  MOVE.L #$AA5555AA,INZFLG SET INITIALIZED FLAG
	  BSR	CRLF
	  MOVE.L #H68MSG,A4
	  BSR	PDATA		   PRINT SIGN-ON

*******************************************************
* NXTCMD - INITIALIZATION COMPLETE. READY FOR COMMAND
*******************************************************

NXTCMD	  MOVE.L #MSTACK-6,A7	   RESET STACK PTR TO MON AREA
NXTCM1	  JSR CRLF		   PRINT CR/LF
	  MOVE.B #$2A,D4	   PRINT PROMPT
	  JSR OUTEEE
	  JSR INEEE		   GET FIRST COMMAND CHARACTER
	  LSL.W #8,D5		   MOVE INTO SECOND BYTE
	  JSR INEEE		   GET SECOND COMMAND CHARACTER
	  AND.W #$DFDF,D5	   CVT TO UPPER CASE >>A<<
	  JSR OUTS

* CHECK COMMAND

COMAND	  LEA COMTAB-6,A0	   GET ADDR OF COMMAND TABLE-6
	  LEA TABEND,A1 	   AND END OF TABLE
LOOKUP	  ADD.L #6,A0		   POINT TO NEXT ENTRY
	  CMP.L A0,A1		   END OF TABLE?
	  BEQ.S COMEND		   YES
	  CMP.W (A0),D5 	   CHECK THE COMMAND AGAINST TABLE
	  BNE.S LOOKUP		   WRONG
	  MOVE.L 2(A0),A0	   GET ADDRESS IF OK
	  JSR OUTS		   PRINT A SPACE
	  JSR (A0)		   JUMP TO APPROP COMMAND ROUTINE
	  BRA.S NXTCMD
COMEND	  MOVE.B #$3F,D4	   PRINT ? IF NOT FOUND
	  BSR	OUTEEE
	  BRA.S NXTCMD

*******************************************************
* COMMAND TABLE
*******************************************************

COMTAB	  FCC 'AD' FORMATTED ASCII DUMP
	  LONG ASCDMP
	  FCC 'AI' ASCII INPUT
	  LONG ASCIN
	  FCC 'AO' ASCII OUT
	  LONG ASCOUT
	  FCC 'BP' PRINT BP LOCATIONS
	  LONG BPRINT
	  FCC 'BR' SET/RESET BPS
	  LONG BREAK
	  FCC 'CO' CONTINUE AFTER BP
	  LONG CONT
	  FCC 'CS' FOUR-BYTE CHECKSUM
	  LONG SUM
	  FCC 'FI' FIND BYTES COMMAND
	  LONG FIND
	  FCC 'FM' FILL MEMORY
	  LONG FILL
	  FCC 'HA' COMBINED HEX AND ASCII DUMP
	  LONG HEXASC
	  FCC 'HD' HEX DUMP ROUTINE
	  LONG HEXDMP
	  FCC 'HE' HELP
	  LONG HELP
	  FCC 'JS' JUMP TO SYSTEM PROGRAM
	  LONG JUMPS
	  FCC 'JU' JUMP TO USER PROGRAM
	  LONG JUMPU
	  FCC 'LO' LOAD S1S9 FORMAT TAPE
	  LONG LOAD
	  FCC 'MC' MEMORY COMPARE
	  LONG COMPAR
	  FCC 'ME' MEMORY EXAMINE
	  LONG CHANGE
	  FCC 'MO' MOVE MEMORY CONTENTS
	  LONG MOVE
	  FCC 'MS' MEMORY STORE W/O READING
	  LONG MSTORE
	  FCC 'MT' MEMORY TEST
	  LONG MTEST
	  FCC 'RC' REGISTER CHANGE
	  LONG REGCHG
	  FCC 'RE' REGISTER EXAMINE
	  LONG REGIST
	  FCC 'SS' SINGLE-STEP
	  LONG STEP
	  FCC 'ST' START SINGLE-STEPPING
	  LONG STRTSS
	  FCC 'TB' TINY BASIC COLD
	  LONG TBASIC
	  FCC 'TW' TINY BASIC WARM
	  LONG WBASIC
	  FCC 'XM'
	  LONG XMODEM
	  DEFW $0101 !!=FORCE POWERUP INITIALIZATION
	  LONG RESTRT
TABEND	  DEFW 0 MARKS END OF TABLE

*******************************************************
* 'MS' - MEMORY STORE WITHOUT READING
*******************************************************

MSTORE	  LEA ADMSG,A4
	  JSR PDATA		   PRINT "ADDRESS: "
	  BSR	BADDR		   GET ADDRESS
	  MOVE.L D5,A0
	  SUB.L #1,A0		   BACKUP 1
	  MOVE.L BUSERV+2,A2	   TEMP SAVE BUS ERROR VECTOR
	  MOVE.L #MSBERR,BUSERV+2  REPLACE WITH NEW VECTOR
MSTOR1	  ADD.L #1,A0		   THEN GO FORWARD
MSTOR2	  MOVE.L A0,D4		   PREPARE TO PRINT
	  JSR CRLF
	  JSR OUT8HS		   PRINT ADDRESS
MSTOR3	  JSR INEEE		   INPUT COMMAND CHAR
	  CMP.B #$0D,D5
	  BEQ.S MSEXIT		   QUIT ON CR
	  CMP.B #$5E,D5 	   UP ARROW?
	  BNE.S MSTOR4		   NO
	  SUB.L #1,A0		   YES, STEP BACK
	  BRA.S MSTOR2		   AND REPEAT
MSTOR4	  JSR CVTHEX		   PROCESS THE DIGIT
	  BEQ.S MSTOR1		   ON SPACE GO TO NEXT
	  MOVE.B D5,D0		   SAVE FIRST DIGIT
	  LSL.B #4,D0		   IN LEFT NYBBLE
	  BSR	IN1HEX		   GET SECOND DIGIT
	  BEQ.S MSTOR1		   ON SPACE GO TO NEXT
	  ADD.B D5,D0		   COMBINE THE TWO DIGITS
	  MOVE.B D0,(A0)	   STORE NEW NUMBER
	  BRA.S MSTOR1		   AND THEN DO THE NEXT
MSBERR	  LEA MEBMSG(PC),A4
	  JSR PDATA		   PRINT "BUSS ERROR"
	  BRA.S MSTOR1
MSEXIT	  MOVE.L A2,BUSERV+2	   RESTORE BUS ERROR VECTOR
	  JMP NXTCMD		   THEN DO NEXT COMMAND

*******************************************************
* 'ME' - MEMORY EXAMINE AND CHANGE FUNCTION
*******************************************************

CHANGE	  LEA ADMSG,A4
	  JSR PDATA		   PRINT "ADDRESS: "
	  BSR	BADDR		   GET ADDRESS
	  MOVE.L D5,A0
	  SUB.L #1,A0		   BACKUP 1
CHANG0	  MOVE.L BUSERV+2,A2	   TEMP SAVE BUS ERROR VECTOR
	  MOVE.L #MEBERR,BUSERV+2  REPLACE WITH NEW VECTOR
CHANG1	  ADD.L #1,A0		   THEN GO FORWARD
CHANG2	  MOVE.L A0,D4		   PREPARE TO PRINT
	  JSR CRLF
	  JSR OUT8HS		   PRINT ADDRESS
	  MOVE.B (A0),D4	   GET THE OLD DATA
	  JSR OUT2HS		   PRINT IT
	  JSR OUTS		   SPACE
CHANG3	  JSR INEEE		   INPUT COMMAND CHAR
	  CMP.B #$0D,D5
	  BEQ.S MEEXIT		   QUIT ON CR
	  CMP.B #$5E,D5 	   UP ARROW?
	  BNE.S CHANG4		   NO
	  SUB.L #1,A0		   YES, STEP BACK
	  BRA.S CHANG2		   AND REPEAT
CHANG4	  JSR CVTHEX		   PROCESS THE DIGIT
	  BEQ.S CHANG1		   ON SPACE GO TO NEXT
	  MOVE.B D5,D0		   SAVE FIRST DIGIT
	  LSL.B #4,D0		   IN LEFT NYBBLE
	  BSR.S IN1HEX		   GET SECOND DIGIT
	  BEQ.S CHANG1		   ON SPACE GO TO NEXT
	  ADD.B D5,D0		   COMBINE THE TWO DIGITS
	  MOVE.B D0,(A0)	   STORE NEW NUMBER
	  CMP.B (A0),D0 	   CMPA -1,X CHECK IT
	  BEQ.S CHANG1		   STORED OK, DO NEXT
	  LEA NOCMSG(PC),A4	   ERROR IF NOT STORED OK
	  JSR PDATA		   PRINT "DID NOT STORE"
	  BRA.S CHANG2		   DO SAME ONE AGAIN
MEBERR	  LEA MEBMSG(PC),A4
	  JSR PDATA		   PRINT "BUSS ERROR"
MEEXIT	  MOVE.L A2,BUSERV+2	   RESTORE BUS ERROR VECTOR
	  JMP NXTCMD		   THEN DO NEXT COMMAND

*******************************************************
* VARIOUS ROUTINES NEEDED TO SUPPORT ABOVE ETC.
*******************************************************

* BUILD ADDRESS. BUILDS AN ADDRESS IN D5; UNLIMITED NUMBER OF
* DIGITS ACCEPTED UNTIL A SPACE IS ENTERED.
* ANY OTHER NON-HEX CHARACTER ABORTS AND RETURNS TO NXTCMD

BADDR	  CLR.L D6
BADDR1	  BSR.S IN1HEX		   GET 1 HEX DIGIT
	  BEQ.S BADEXI		   EXIT IF A SPACE
	  LSL.L #4,D6		   MOVE PREVIOUS NUMBER LEFT
	  ADD.B D5,D6		   COMBINE WITH LATEST DIGIT
	  BRA.S BADDR1		   AND REPEAT
BADEXI	  MOVE.L D6,D5		   ANSWER INTO D5
	  RTS

* INPUT BYTE (TWO HEX DIGITS)
* ANY NON-HEX CHARACTER EXCEPT SPACE ABORTS AND RETURNS TO COMEND

BYTE	  BSR.S IN1HEX		   GET ONE HEX DIGIT
	  BEQ.S BYTE		   SKIP SPACE
BYTE1	  LSL.B #4,D5
	  MOVE.B D5,D6		   TEMP SAVE IT
BYTE2	  BSR.S IN1HEX		   GET SECOND HEX DIGIT
	  BEQ.S BYTE2		   SKIP SPACE
	  ADD.B D6,D5		   COMBINE
	  ADD.B D5,D1		   ADD TO CHECKSUM (IN LOAD S1)
	  RTS

* INPUT 1 HEX DIGIT
* ANY NON-HEX CHARACTER ABORTS AND RETURNS TO COMEND

IN1HEX	  BSR	INEEE
CVTHEX	  CMP.B #$20,D5 	   IS IT A SPACE?
	  BEQ.S IHEXIT		   YES, EXIT WITH EQUALS
	  SUB.B #$30,D5 	   CVT FROM ASCII
	  CMP.B #$A,D5		   CHECK IF 0-9
	  BCS.S IHEXIT		   YES, EXIT
	  AND.B #$DF,D5 	   CVT TO UPPER >>B<<
	  CMP.B #$11,D5 	   CHECK IF <A
	  BCS	COMEND		   YES, ERROR
	  SUB.B #7,D5		   TAKE A CHANCE THAT IT'S A-F
	  CMP.B #$10,D5 	   CHECK IF IT'S VALID
	  BCC	COMEND		   ERROR IF 10 OR ABOVE
IHEXIT	  RTS			   RTS

* OUTHL AND R - OUTPUT ONE HEX DIGIT

OUTHL	  LSR.B #4,D4		   OUTPUT LEFT DIGIT ENTRY
OUTHR	  AND.B #$F,D4		   OUTPUT HEX RIGHT DIGIT ENTRY
	  ADD.B #$30,D4
	  CMP.B #$39,D4 	   0-9?
	  BLS	OUTEEE		   YES, OUTPUT IT
	  ADD.B #$7,D4		   ELSE CONVERT FOR A - F
	  BRA	OUTEEE		   AND OUTPUT

* OUT2, 4, AND 8 HEX ROUTINES

OUT2H	  MOVE.B D4,D5		   SAVE BYTE IN D5
	  BSR.S OUTHL		   OUTPUT LEFT HEX CHAR
	  MOVE.B D5,D4		   RESTORE BYTE
	  BRA.S OUTHR		   OUTPUT RIGHT HEX CHAR

OUT8HS	  SWAP D4
	  BSR.S OUT4H		   LEFT 4 DIGITS FIRST
	  SWAP D4
	  BSR.S OUT4H		   RIGHT 4 DIGITS NEXT
	  BRA.S OUTS		   FOLLOW WITH SPACE

OUT4H	  MOVE.W D4,D6		   SAVE WORD IN D6
	  LSR.W #8,D4
	  BSR.S OUT2H		   LEFT BYTE FIRST
	  MOVE.W D6,D4		   RESTORE WORD
	  BRA.S OUT2H		   RIGHT BYTE NEXT
	  RTS

OUT4HS	  BSR.S OUT4H
	  BRA.S OUTS

OUT2HS	  BSR.S OUT2H
OUTS	  MOVE.B #$20,D4	   SPACE
	  BSR	OUTEEE
	  RTS			   AND RETURN

*******************************************************
* JUMP TO USER PROGRAM COMMAND; PUT RETURN ADDRESS ON HIS STACK
* SO HE'LL RETURN TO WARM START IF HE DOES RTS
*******************************************************

JUMPU	  LEA STMSG,A4
	  JSR PDATA		   PRINT "FROM ADDRESS"
* USE -8 IN FOLLOWING INSTRUCTION FOR 68010/68020
	  MOVE.L #MSTACK-6,A7	   RESET STACK
	  BSR	BADDR		   GET ADDRESS TO JUMP TO
	  BTST #0,D5
	  BNE	ODDADD		   IF NOT EVEN
	  MOVE.L D5,2(A7)	   PUT ON STACK
	  BEQ	COMEND		   NG IF ZERO
	  MOVE.W #$0700,(A7)	   SET SR
* INCLUDE FOLLOWING INSTRUCTION FOR 68010/68020
*	  CLR.W 6(A7)		   CLEAR 68010/20 FORMAT CODE
	  MOVE.L #USTACK-4,A6
	  MOVE.L A6,USP 	   SET USER STACK REGISTER
	  LEA WARMST(PC),A6	   POINT TO WARMSTART
	  MOVE.L A6,USTACK-4	   PUT IT ON USER STACK
	  MOVEM.L REGERS,D0-D7/A0-A6 RESET A&D REGISTERS
	  RTE			   GO TO USER


*******************************************************
* JUMP TO SYSTEM PROGRAM COMMAND; PUT RETURN ADDRESS ON STACK
* SO HE'LL RETURN TO WARM START IF HE DOES RTS
*******************************************************

JUMPS	  LEA STMSG,A4
	  JSR PDATA		   PRINT "FROM ADDRESS"
	  BSR	BADDR		   GET ADDRESS TO JUMP TO
	  BTST #0,D5
	  BNE	ODDADD		   IF NOT EVEN
	  MOVE.L #SSTACK,A7	   INITIALIZE STACK TO SYST AREA
	  LEA WARMST,A0
	  MOVE.L A0,-(A7)	   WARMST ADDR ON STACK
	  MOVE.L D5,-(A7)	   AND GO TO ADDRESS ON STACK
	  BEQ	COMEND		   NG IF ZERO
	  MOVEM.L REGERS,D0-D7/A0-A6 RESET A&D REGISTERS
	  RTS			   GO TO SYST PROGRAM

*******************************************************
* PSTRNG AND PCRLF
*******************************************************

* CRLF - PRINT CR/LF
CRLF	  MOVEM.L A4-A4,-(A7)
	  MOVE.L #CRLFST,A4	   POINT TO CRLF STRING
	  BSR.S PDATA		   PRINT AND RETURN
	  MOVEM.L (A7)+,A4-A4
	  RTS
CRLFST	  FCB $0D,$0A,4

* PSTRNG - CRLF FOLLOWED BY PDATA
PSTRNG	  BSR.S CRLF

* PDATA - PRINT DATA STRING
PDATA	  MOVEM.L D4-D4,-(A7)
PDATA1	  MOVE.B (A4)+,D4	   GET CHARACTER
	  CMP.B #4,D4		   END?
	  BEQ.S PDEXIT
	  BSR	OUTEEE
	  BRA.S PDATA1		   AND REPEAT
PDEXIT	  MOVEM.L (A7)+,D4-D4
	  RTS

*******************************************************
* CONSOLE I/O ROUTINES
*******************************************************

* INEEE - CHARACTER INPUT ROUTINE
INEEE
INRPT	  BSR	INCH7		   GET INPUT CHARACTER
	  CMP.B #$13,D5 	   IS IT CONTROL-S?
	  BEQ.S GOTCS		   YES
	  TST.B PORECH		   ECHO?
	  BEQ.S NOECHO		   NO
	  MOVEM.L D4-D4,-(A7)	   YES
	  MOVE.B D5,D4
	  BSR	OUTEEE
	  MOVEM.L (A7)+,D4-D4
NOECHO	  RTS

* CONTROL-S DETECTED. GET AND INTERPRET COMMAND
GOTCS	  BSR.S GETCMD		   DO COMMAND
	  BRA.S INRPT

* SUBR TO GET AND DO COMMAND
GETCMD	  MOVE.B D4,D5		   SAVE CHARACTER BEING OUTPUT
	  MOVE.B #$07,D4
	  JSR OUTCHM		   ECHO CONTROL-G (BELL) ON CTL PORT
	  MOVE.B D5,D4		   RESTORE CHARACTER
	  BSR.S INCH7		   GET SECOND CHARACTER OF CMD
	  CMP.B #$60,D5 	   CHECK FOR LOWER CASE >>F<<
	  BCS.S NOTLCS		   NOT LOWER >>F<<
	  SUB.B #$20,D5 	   ELSE CHANGE TO UPPER CASE >>F<<
NOTLCS	  CMP.B #$50,D5 	   P - PORT P COMMAND? >>F<<
	  BNE.S NOT0		   NO
	  EOR.B #$80,STATUS	   FLIP PORT P
	  RTS			   AND RETURN
NOT0	  CMP.B #$43,D5 	   C - PORT C COMMAND?
	  BNE.S NOT1		   NO
	  EOR.B #$40,STATUS	   FLIP PORT C
	  RTS
NOT1	  CMP.B #$58,D5 	   X - PORT X COMMAND?
	  BNE.S NOTD		   NO
	  EOR.B #$10,STATUS	   FLIP PORT X
	  RTS
NOTD	  CMP.B #$57,D5 	   W - PAUSE COMMAND?
	  BNE.S NOTP		   NO
	  EOR.B #$08,STATUS	   FLIP PAUSE
	  MOVE.B #$F,PAUCTR	   RESET PAUSE LINE CNTR
	  RTS
NOTP	  CMP.B #$0D,D5 	   CR COMMAND TO QUIT?
	  BEQ	WARMST		   YES, QUIT
	  CMP.B #$08,D5 	   ^X COMMAND TO QUIT?
	  BEQ	WARMST		   YES, QUIT
NOTCR	  RTS			   RETURN W/O DOING ANYTHING

* ACTUAL CONTROL PORT INPUT ROUTINES
INCH7	  BSR	INCH8		   GET 7-BIT CHARACTER
	  AND.B #$7F,D5 	   MASK OUT PARITY
	  RTS

* OUTEEE - CHARACTER OUTPUT ROUTINE

OUTEEE	  MOVEM.L A6-A6,-(A7)
OUTEE1	  BSR	INCHEK		   CHECK FOR INPUT CHARACTER
	  BEQ.S NOTEST		   NO CHARACTER
	  BSR.S INCH7		   GET CHARACTER
	  CMP.B #$13,D5 	   IS IT CONTROL-S?
	  BNE.S NOTEST		   NO
	  BSR	GETCMD		   YES; GET COMMAND AND DO IT
* CHECK FOR PAUSE
NOTEST	  BTST #3,STATUS	   PAUSE ON?
	  BEQ.S NOPAUS		   NO
	  CMP.B #$0D,D4 	   CR? >>D<<
	  BNE.S NOPAUS		   ONLY PAUSE AT END OF LINE
	  SUB.B #1,PAUCTR	   DECR PAUSE LINE CNTR
	  BNE.S NOPAUS		   AND CHECK IT
* LINE DELETED HERE BY >>D<<
	  MOVE.B #$0F,PAUCTR	   MUST PAUSE. RESET CNTR
	  BSR.S INCH7		   WAIT FOR RESTART CHAR
	  CMP.B #$0D,D5 	   QUIT IF IT'S A CR
	  BEQ	NXTCMD
NOPAUS	  TST.B STATUS		   PRINT ON PORT P?
	  BPL.S NOTPT0		   NO
	  BSR	OUTCHP		   YES
NOTPT0	  BTST #6,STATUS	   PRINT ON CTL PORT?
	  BEQ.S NOTPTM		   NO
	  BSR	OUTCHM		   YES
NOTPTM	  BTST #4,STATUS	   OUTPUT ON D?
	  BEQ.S NOTPTD		   NO
	  MOVEM.L D4-D4,-(A7)	      SAVE CHAR
	  MOVE.L DVECTR,A6
	  JSR (A6)		   YES
	  MOVEM.L (A7)+,D4-D4	   RESTORE CHAR
NOTPTD	  MOVEM.L (A7)+,A6-A6
	  RTS

* ALTERNATE OUTEEE ENTRY W/O CTRL-S TEST

OUTNOT	  MOVEM.L A6-A6,-(A7)	   SAVE REGISTER
	  BRA.S NOTEST

*******************************************************
* 'RC' - REGISTER CHANGE
*******************************************************

REGCHG	  MOVE.L #WHMESG,A4
	  JSR PDATA		   ASK WHICH REGISTER
	  JSR INEEE		   GET FIRST LETTER
	  MOVE.B D5,D0		   MOVE INTO D0
	  LSL.W #8,D0		   MOVE LEFT 1 BYTE
	  JSR INEEE		   GET SECOND
	  MOVE.B D5,D0		   COMBINE WITH FIRST
	  OR.W #$2020,D0	   UPPER TO LOWER CASE >>C<<
	  CMP.W #$7573,D0	   IS IT 'US'? >>C<<
	  BEQ.S RCUS		   YES
	  CMP.W #$7373,D0	   IS IT 'SS'? >>C<<
	  BEQ.S RCSS		   YES
	  MOVE.B #18,D1 	   COUNT 18 REG NAMES
	  LEA REGERS-1,A0	   POINT TO REGISTERS
	  LEA RNAMES(PC),A1	   POINT TO NAME TABLE
RCLOOP	  CMP.W (A1)+,D0	   COMPARE NAME
	  BEQ.S RCOK		   IF LETTER FOUND
	  ADD.L #4,A0		   POINT TO NEXT REGISTER
	  SUB.B #1,D1		   CHECK COUNTER
	  BNE.S RCLOOP		   LOOP TIL DONE
	  JMP COMEND		   QUIT WITH '?' IF NG
RCSS	  LEA SYSTSP-1,A0
	  JMP CHANG0		   GO TO 'ME' IF OK
RCUS	  LEA USERSP-1,A0
RCOK	  JMP CHANG0		   GO TO 'ME' IF OK
RNAMES	  FCC 'd0d1d2d3d4d5d6d7a0a1a2a3a4a5a6a7'    >>C<<
	  FCC 'pcsr'               REGISTER NAMES   >>C<<
********************************************************
* "LO" COMMAND - LOAD S1S9 FORMAT FORMAT TAPE
********************************************************

LOAD	  MOVE.B PORECH,-(SP)	   SAVE PORT ECHO
	  CLR D1
	  MOVE.B D1,PORECH	   SET ECHO OFF
LD0	  MOVE.B #$11,D4	   PRINT CTRL-Q
	  JSR OUTEEE
LD1	  JSR INEEE		   GET THE FIRST CHAR
	  CMP.B #$53,D5 	   S?
	  BNE.S LD1		   1ST CHAR NOT S
	  JSR INEEE		   GET NEXT CHAR
	  CMP.B #$39,D5 	   S9?
	  BEQ	LOAD21		   YES, FINISH LOADING
	  CMP.B #$38,D5 	   S8?
	  BEQ	LOAD21		   YES, FINISH LOADING
	  CMP.B #$37,D5 	   S7?
	  BEQ.S LOAD21		   YES, FINISH LOADING
	  CMP.B #$31,D5 	   S1?
	  BEQ.S LOADS1		   YES
	  CMP.B #$32,D5 	   S2?
	  BEQ.S LOADS2		   YES
	  CMP.B #$33,D5 	   S3?
	  BEQ	LOADS3		   YES
	  BRA.S LD1		   2ND CHAR NOT VALID

* LOAD S1 ROUTINE - 2-BYTE ADDRESS
LOADS1	  CLR.L D1		   ZERO CHECKSUM
	  JSR BYTE		   READ BYTE (D5) & CSUM
	  SUB.B #2,D5
	  CLR.L D2		   ZERO COUNTER (D2)
	  MOVE.B D5,D2		   SET COUNTER
	  CLR.L D5
LOADR2	  JSR BYTE		   GET ADDRESS BYTE & CSUM
	  LSL.L #8,D5		   MOVE INTO NEXT BYTE
	  JSR BYTE		   SECOND ADDRESS BYTE & CSUM
	  MOVE.L D5,A0		   FORM ADDRESS
* STORE DATA
LOAD11	  JSR BYTE		   GET BYTE TO LOAD & CSUM
	  SUB.L #1,D2		   DECR COUNT
	  BEQ.S LOAD15		   ZERO BYTE COUNT?
	  MOVE.B D5,(A0)	   STORE DATA
	  CMP.B (A0),D5 	   DATA STORED?
	  BNE.S LOAD19
	  ADD.L #1,A0		   NEXT ADDRESS
	  BRA.S LOAD11
LOAD15	  EOR.B #$FF,D1 	   COMPLEMENT CHECKSUM
	  BEQ	LD0		   OK IF ZERO
LOAD19	  MOVE.B #$3F,D4	   PRINT ? IF ERROR
	  JSR OUTEEE

LOAD21	  MOVE.B (SP)+,PORECH	   RESTORE PORT ECHO
	  JMP NXTCMD		   QUIT WHEN DONE

* LOAD S2 ROUTINE - 3-BYTE ADDRESS
LOADS2	  CLR.L D1		   ZERO CHECKSUM
	  JSR BYTE		   READ BYTE (D5) (CSUM)
	  SUB.B #3,D5
	  CLR.L D2		   ZERO COUNTER (D2)
	  MOVE.B D5,D2		   SET COUNTER
	  CLR.L D5
LOADR3	  JSR BYTE		   GET ADDRESS BYTE & CSUM
	  LSL.W #8,D5		   MOVE INTO NEXT BYTE
	  BRA.S LOADR2		   READ 2 MORE BYTES, CONTINUE

* LOAD S3 ROUTINE - 4-BYTE ADDRESS
LOADS3	  CLR.L D1		   ZERO CHECKSUM
	  JSR BYTE		   READ BYTE (D5) (CSUM)
	  SUB.B #4,D5
	  CLR.L D2		   ZERO COUNTER (D2)
	  MOVE.B D5,D2		   SET COUNTER
	  CLR.L D5
	  JSR BYTE		   GET ADDRESS BYTE & CSUM
	  LSL.W #8,D5		   MOVE INTO NEXT BYTE
	  BRA.S LOADR3		   READ 3 MORE BYTES, CONTINUE

********************************************************
* 'HD' HEX DUMP COMMAND
* 'AD' ASCII DUMP COMMAND
* 'HA' COMBINED HEX AND ASCII DUMP
********************************************************

HEXDMP	  MOVE.B #$FF,D0	   HD IS <0 FLAG
	  BRA.S HDADHA
ASCDMP	  CLR.B D0		   AD IS =0 FLAG
	  BRA.S HDADHA
HEXASC	  MOVE.B #$1,D0 	   HA IS >0 FLAG

HDADHA	  JSR FROMTO
	  MOVE.L BEGA,D4	   GET STARTING ADDRESS
	  MOVE.L D4,A0		   STORE IT
	  MOVE.L D4,A1		   WORKING COPY
DUMP	  JSR CRLF		   JSR CRLF
	  MOVE.L A1,D4
	  CMP.L #$10000,D4	   NEED 4 OR 8 DIGITS?
	  BCS.S DUMP0		   4 IF <10000
	  JSR OUT8HS		   ELSE USE 8
	  BRA.S DUMP1
DUMP0	  JSR OUT4HS		   PRINT ADDRESS
DUMP1	  JSR OUTS		   EXTRA SPACE
	  TST.B D0		   CHECK FLAG
	  BEQ.S ONLYAS		   ONLY ASCII IF FLAG=0
	  MOVE.B #16,D1 	   SET COUNTER TO 16
DUMP2	  MOVE.W A1,D4
	  AND.B #$07,D4 	   ON 0 OR 8 BOUNDARY?
	  BNE.S DUMP2A		   NO
	  JSR OUTS		   YES, SKIP SPACE
DUMP2A	  MOVE.B (A1)+,D4	   GET THE BYTE
	  JSR OUT2HS		   PRINT NEXT BYTE
	  SUB.B #1,D1		   DECREMENT COUNTER
	  BNE.S DUMP2		   CONTINUE LINE IF NOT FINISHED
	  TST.B D0		   SHOULD WE DO ASCII?
	  BMI.S NOASCI		   DON'T DO IF MINUS
	  MOVE.L A0,A1		   RESTORE WORKING ADDRESS
	  JSR OUTS		   PRINT ANOTHER SPACE
ONLYAS	  MOVE.B #16,D1 	   SET COUNTER TO 16 AGAIN
DUMP3	  MOVE.W A1,D4
	  AND.B #$07,D4 	   ON 0 OR 8 BOUNDARY?
	  BNE.S DUMP3A		   NO
	  JSR OUTS		   YES, SKIP SPACE
DUMP3A	  MOVE.B (A1)+,D4	   GET THE BYTE
	  AND.B #$7F,D4 	   MASK OFF PARITY BIT
	  CMP.B #$7E,D4
	  BCC.S DUMP4		   SUBSTITUTE . FOR 7E,7F
	  CMP.B #$20,D4
	  BCC.S DUMP5		   PRINT SPACE AND ABOVE
DUMP4	  MOVE.B #$2E,D4	   SUBSTITUTE . FOR ALL ELSE
DUMP5	  JSR OUTEEE		   PRINT IT
	  SUB.B #1,D1		   DECREMENT COUNTER
	  BNE.S DUMP3		   CONTINUE LINE IF NOT FINISHED
NOASCI	  MOVE.L A1,A0		   SAVE CURRENT
	  CMP.L ENDA,A1 	   ARE WE DONE?
	  BCS	DUMP		   NO, DO NEXT LINE
	  RTS


********************************************************
* FROMTO SUBR - INITIALIZE BEGA AND ENDA ADDRESSES
********************************************************

FROMTO	  LEA FROMST,A4
	  JSR PDATA		   PRINT "FROM "
	  JSR INEEE		   GET CHARACTER
	  CMP.B #$0D,D5 	   IS IT A CR?
	  BEQ	CRLF		   ON CR, DO CRLF AND RETURN
	  JSR CVTHEX		   CONVERT TO HEX
	  BEQ	NXTCMD		   ABORT IF SPACE
	  CLR.L D6
	  MOVE.B D5,D6		   READY TO FINISH WITH BADDR
	  JSR BADDR1		   GET REST OF NUMBER
	  MOVE.L D5,BEGA	   BEGINNING ADDRESS
	  LEA TOSTR(PC),A4
	  JSR PDATA		   PRINT "TO "
	  JSR BADDR		   GET TO ADDRESS
	  MOVE.L D5,ENDA	   STORE IT
	  JMP OUTS		   AND EXIT

********************************************************
* "FI" COMMAND - FIND 1 TO 5 BYTES IN MEMORY
********************************************************

FIND	  LEA MANYST,A4
	  JSR PDATA		   ASK "HOW MANY BYTES"
	  JSR INEEE		   GET NUMBER
	  SUB.B #$30,D5 	   CONVERT FROM ASCII
	  BEQ	CRLF		   IF = 0
	  CMP.B #$5,D5
	  BHI	CRLF		   IF GREATER THAN 3
	  MOVE.B D5,D3		   STORE NUMBER OF BYTES
	  MOVE.B D5,D2		   BACKUP COPY
	  JSR OUTS
	  LEA WHATST(PC),A4
	  JSR PDATA		   ASK "WHAT BYTES"
	  LEA WHAT,A0		   WHERE TO PUT DESIRED BYTES
FIENTR	  JSR BYTE		   ENTER A BYTE
	  MOVE.B D5,(A0)+	   STORE IT
	  SUB.B #1,D3
	  BNE.S FIENTR		   ENTER MORE, IF NEEDED
	  JSR FROMTO		   GET BEGA AND ENDA
	  MOVE.L BEGA,A0	   GET READY TO LOOK
FIND1	  MOVE.B D2,D1		   RESET NUMBER OF BYTES
	  MOVE.B (A0),D0	   GET FIRST BYTE
	  CMP.B WHAT,D0
	  BNE.S FIND4		   WRONG BYTE
	  SUB.B #1,D1
	  BEQ.S FIND2		   FOUND ONE CORRECT BYTE
	  MOVE.B 1(A0),D0	   GET SECOND BYTE
	  CMP.B WHAT+1,D0
	  BNE.S FIND4		   WRONG
	  SUB.B #1,D1
	  BEQ.S FIND2		   FOUND TWO CORRECT BYTES
	  MOVE.B 2(A0),D0	   GET THIRD BYTE
	  CMP.B WHAT+2,D0
	  BNE.S FIND4		   WRONG
	  SUB.B #1,D1
	  BEQ.S FIND2		   FOUND THREE CORRECT BYTES
	  MOVE.B 3(A0),D0	   GET FOURTH BYTE
	  CMP.B WHAT+3,D0
	  BNE.S FIND4		   WRONG
	  SUB.B #1,D1
	  BEQ.S FIND2		   FOUND FOUR CORRECT BYTES
	  MOVE.B 4(A0),D0	   GET FIFTH BYTE
	  CMP.B WHAT+4,D0
	  BNE.S FIND4		   WRONG BYTE
FIND2	  BSR	CRLF		   PRINT CRLF
	  MOVE.L A0,D4
	  BSR	OUT8HS		   PRINT ADDRESS
	  JSR OUTS		   ONE MORE SPACE
	  LEA -1(A0),A1 	   BACKUP ONE BYTE
	  MOVE.B #7,D1		   READY TO PRINT SEVEN BYTES
FIND3	  MOVE.B (A1)+,D4
	  JSR OUT2HS		   PRINT BYTE
	  CMP.B #7,D1		   BEFORE SECOND BYTE?
	  BNE.S FIND3A		   NO
	  MOVE.B #$3E,D4	   POINT TO IT
	  JSR OUTEEE
FIND3A	  SUB.B #01,D1
	  BNE.S FIND3		   PRINT FOUR BYTES
FIND4	  CMP.L ENDA,A0 	   SEE IF DONE
	  BEQ	CRLF		   YES
	  ADD.L #1,A0		   NO
	  BRA	FIND1		   KEEP LOOKING

********************************************************
* "FM" COMMAND - FILL MEMORY WITH CONSTANT
********************************************************

FILL	  JSR FROMTO		   GET FROM-TO ADDRESSES
	  LEA WITHST,A4
	  JSR PDATA		   ASK FOR DATA
	  JSR BYTE		   INPUT
	  MOVE.L BEGA,A0	   GET STARTING ADDRESS
	  MOVE.L ENDA,A1	   ENDING ADDRESS
	  ADD.L #1,A1		   SIMPLIFY COMPARISON
FILOOP	  MOVE.B D5,(A0)+	   STORE THE BYTE
	  CMP.L A1,A0		   SEE IF DONE
	  BNE.S FILOOP		   CONTINUE OF NO
	  RTS			   QUIT WHEN DONE

********************************************************
* SUM - MEMORY CHECKSUM
********************************************************

SUM	  JSR FROMTO		   GET ADDRESS LIMITS
	  MOVE.L BEGA,A0	   GET STARTING ADDRESS
	  MOVE.L ENDA,A1	   GET ENDING ADDRESS
	  CLR.L D0
	  CLR.L D1
SUMLP	  MOVE.B (A0)+,D1	   GET BYTE
	  ADD.L D1,D0		   ADD INTO CHECKSUM
	  CMP.L ENDA,A0 	   LAST ADDRESS?
	  BLS.S SUMLP		   NO, REPEAT
SUMDON	  MOVE.L D0,D4
	  JSR OUT8HS		   OUTPUT CHECKSUM
	  RTS

********************************************************
* 'MT' - MEMORY TEST
********************************************************

MTEST	  JSR FROMTO		   GET ADDRESS LIMITS
	  MOVE.L BEGA,A0
	  MOVE.L ENDA,A2
LODREG	  MOVE.B (A0),D2	   SAVE OLD CONTENTS
	  MOVE.B #1,D0		   STORE 1 IN MEMORY
	  MOVE.B D0,(A0)
	  CMP.B (A0),D0 	   WAS IT WRITTEN?
	  BNE.S ERRPNT		   NO
ROLP1	  ASL.B #1,D0
	  BEQ.S INCR1		   DONE WHEN ALL ZEROES
	  MOVE.B D0,(A0)	   STORE NEXT BIT
	  CMP.B (A0),D0 	   CHECK IT
	  BEQ.S ROLP1		   OK, DO NEXT BIT
ERRPNT	  JSR CRLF		   ON ERROR
	  MOVE.L A0,D4		   ADDRESS OF WRONG BYTE
	  BSR	OUT8HS		   PRINT IT
	  MOVE.B D0,D4		   INCORRECT BIT
	  JSR OUT2HS		   OUTPUT WHAT SHOULD BE STORED
	  MOVE.B (A0),D4	   WRONG BIT
	  JSR OUT2HS		   OUTPUT WHAT WAS STORED
INCR1	  MOVE.B D2,(A0)	   RESTORE PREVIOUS CONTENTS
	  CMP.L A2,A0		   COMPARE WITH END ADDRESS
	  BEQ.S FINISH
	  ADD.L #1,A0
	  BRA.S LODREG		   DO NEXT BYTE IF NOT DONE
FINISH	  MOVE.B #$2B,D4
	  JSR OUTEEE		   PRINT "+"
	  RTS

********************************************************
* 'AI' COMMAND - ASCII INPUT ROUTINE
********************************************************

ASCIN	  JSR FROMTO		   GET ADDRESS RANGE
	  JSR CRLF
	  MOVE.L ENDA,A1	   GET LAST EMPTY ADDRESS
	  MOVE.L BEGA,A0	   GET STARTING ADDRESS
	  SUB.L #1,A0
ASCI2	  ADD.L #1,A0
	  JSR INEEE		   GET NEXT CHARACTER
	  MOVE.B D5,(A0)	   STORE IT
	  CMP.B (A0),D5 	   SEE IF IT STORED OK
	  BNE.S ASCI3		   NO, ERROR
	  MOVE.L A0,ENDA	   STORE ENDING ADDRESS
	  CMP.L A0,A1		   CHECK IF RUN OUT OF MEMORY
	  BNE.S ASCI2		   NO, SO GET MORE
ASCI3	  LEA ESTR,A4		   MEM FULL OR BAD, SO..
	  JSR PDATA		   PRINT ERROR
	  BRA	NXTCMD		   QUIT

********************************************************
* 'AO' COMMAND - ASCII OUTPUT ROUTINE
********************************************************

ASCOUT	  JSR FROMTO		   GET ADDRESS RANGE
	  JSR CRLF
	  MOVE.L BEGA,A0	   GET STARTING ADDRESS
	  MOVE.L ENDA,A1	   GET ENDING ADDRESS
ASCO2	  MOVE.B (A0),D4	   GET NEXT CHARACTER
	  JSR OUTEEE		   OUTPUT IT
	  CMP.L A0,A1		   SEE IF DONE
	  BEQ.S ASCO3		   YES
	  ADD.L #1,A0
	  BRA.S ASCO2		   REPEAT IF NOT
ASCO3	  RTS			   RETURN WHEN DONE

********************************************************
* 'MO' COMMAND - MOVE MEMORY ROUTINE
********************************************************

MOVE	  LEA OLDSTR,A4
	  JSR PDATA		   ASK FOR OLD ADDRESSES
	  JSR FROMTO
	  JSR CRLF
	  LEA NEWSTR,A4
	  JSR PDATA		   ASK FOR NEW ADDRESS
	  JSR BADDR
	  MOVE.L D5,A2		   SAVE NEW ADDRESS
	  MOVE.L BEGA,A0	   BEGINNING ADDRESS
	  MOVE.L ENDA,A1	   ENDING ADDRESS
* NOW CHECK FOR FORWARD MOVE OR BACKWARD MOVE
	  MOVE.L A0,D0		   BEGINNING
	  SUB.L A2,D0		   SUBTRACT NEW
	  BCS.S BACK		   BACKWARD IF BEGINNING<NEW
	  BNE.S FWD1
MEXIT	  RTS			   NO MOVE IF NEW=OLD
* FORWARD MOVE
FWD1	  MOVE.B (A0)+,(A2)+	   MOVE AND INCREMENT
	  CMP.L A0,A1		   END?
	  BNE.S FWD1		   NO
	  MOVE.B (A0),(A2)	   MOVE LAST BYTE
	  RTS			   RTS
* BACKWARD MOVE
BACK	  MOVE.L A1,D0
	  SUB.L A0,D0		   COMPUTE NEW END
	  ADD.L A2,D0
	  MOVE.L D0,A3		   TFR D,Y
	  MOVE.B (A1),(A3)	   MOVE LAST
BACK1	  CMP.L A0,A1		   DONE?
	  BEQ.S MEXIT		   YES
	  MOVE.B -(A1),-(A3)	   DECREMENT AND MOVE
	  BRA.S BACK1		   AND REPEAT

********************************************************
* 'BR' COMMAND - SET/RESET UP TO FOUR BPS
********************************************************

BREAK	  BSR.S BKNUM		   POINT A0 TO BP IN TABLE
	  BSR.S BERASE		   GO ERASE OLD ONE
	  LEA NEWSTR(PC),A4	   PRINT "ENTER NEW ADDRESS: "
	  JSR PDATA
	  JSR BADDR		   GET ADDRESS
	  BTST #0,D5		   CHECK WHETHER EVEN
	  BNE.S ODDADD		   NO
	  TST.L D5
	  BEQ	COMEND		   NG IF ZERO
	  MOVE.L D5,A1		   POINT TO DESIRED BP
	  MOVE.L D5,(A0)	   STORE ADDRESS IN TABLE
	  MOVE.W (A1),4(A0)	   STORE PRESENT OP CODE
	  MOVE.W #$4AFC,(A1)	   SUBST INVALID INSTRUCTION CODE
	  RTS			   AND RETURN
ODDADD	  LEA ANEMSG(PC),A4
	  JSR PSTRNG		   PRINT "ADDRESS NOT EVEN"
	  JMP NXTCMD

* ERASE PREVIOUS BP, IF ANY, AND RESTORE OP CODE
BERASE	  MOVE.W 4(A0),D1	   GET OP CODE
	  MOVE.L (A0),A1	   GET ADDRESS
	  CMP.L #$FFFFFFFF,A1	   WAS THERE A BP?
	  BEQ.S BEEXIT		   NO, EXIT
	  MOVE.W D1,(A1)	   YES, RESTORE OP CODE
	  MOVE.L #$FFFFFFFF,(A0)   ERASE BP TABLE ENTRY
BEEXIT	  RTS			   AND RETURN

********************************************************
* BKNUM ROUTINE - GET NO OF DESIRED BP & POINT
* TO ITS LOCATION IN BKTAB TABLE
********************************************************

BKNUM	  LEA BNSTR,A4
	  JSR PDATA
	  JSR INEEE		   GET BP NUMBER
	  SUB.B #$30,D5 	   CONVERT FROM ASCII
	  BEQ	NXTCMD		   IF ZERO
	  CMP.B #$4,D5
	  BHI	NXTCMD		   IF GREATER THAN 4
	  CLR.L D0
	  MOVE.B D5,D0
	  JSR OUTS
	  MOVE.W #6,D1
	  MULU D0,D1		   OFFSET INTO TABLE
	  LEA BKTAB-6,A0	   POINT TO BREAKPOINT TABLE
	  LEA 0(A0,D1.L),A0	    POINT TO ENTRY IN TABLE
	  RTS			   RETURN WHEN DONE

********************************************************
* 'BP' COMMAND - PRINT BP LOCATIONS
********************************************************

BPRINT	  MOVE.B #$30,D1	   BP NUMBER IN ASCII
	  LEA BKTAB,A0		   POINT TO TABLE
BPR1	  ADD.B #01,D1		   NEXT BP NUMBER
	  CMP.B #$35,D1 	   STOP AT 5 BPS
	  BNE.S BPR2
	  RTS			   RETURN WHEN DONE
BPR2	  JSR CRLF		   PRINT CR
	  MOVE.L D1,D4		   GET BP NUMBER
	  JSR OUTEEE		   PRINT BP NUMBER
	  JSR OUTS		   PRINT SPACE
	  MOVE.L (A0)+,D4	   GET BP ADDRESS
	  CMP.L #$FFFFFFFF,D4	   IS THERE ONE?
	  BNE.S BPR3		   YES, GO PRINT IT
	  ADD.L #2,A0		   POINT TO NEXT
	  BRA.S BPR1		   AND REPEAT
BPR3	  JSR OUT8HS		   PRINT ADDRESS OF BP
	  MOVE.W (A0)+,D4	   GET OP CODE
	  JSR OUT4HS		   PRINT OP CODE
	  BRA.S BPR1		   AND REPEAT

********************************************************
* 'RE' COMMAND - PRINT USER REGISTERS FROM STACK
********************************************************

REGIST	  JSR CRLF		   JSR CRLF
	  MOVE.W USERSR,D7	   CHECK USER STATUS
	  BTST	 #13,D7 	   CHECK S BIT
	  BEQ.S A7ISUS		   ZERO MEANS A7 IS USP
	  MOVE.L SYSTSP,D7	   ELSE A7 IS SYSTEM SP
	  BRA.S OKONA7
A7ISUS	  MOVE.L USERSP,D7	   A7 IS USER SP
OKONA7	  MOVE.L D7,REGA7
	  LEA REMSG,A4		   POINT TO COLUMN HEADER
	  JSR PDATA		   PRINT HEADER
	  JSR CRLF
	  LEA REGERS,A0 	   POINT TO REGISTER TABLE
	  LEA DMSG,A4
	  JSR PDATA		   PRINT "D: "
	  MOVE.B #8,D0		   COUNT D REGISTERS
DPLOOP	  MOVE.L (A0)+,D4	   GET NEXT
	  JSR OUT8HS		   OUTPUT D REGISTER
	  SUB.B #1,D0		   DECREMENT COUNTER
	  BNE.S DPLOOP		   REPEAT UNTIL DONE
	  JSR CRLF		   NEXT LINE
	  LEA AMSG,A4
	  JSR PDATA		   PRINT "A: "
	  MOVE.B #8,D0		   COUNT A REGISTERS
APLOOP	  MOVE.L (A0)+,D4	   GET NEXT
	  JSR OUT8HS		   OUTPUT A REGISTER
	  SUB.B #1,D0		   DECREMENT COUNTER
	  BNE.S APLOOP		   REPEAT UNTIL DONE
	  JSR CRLF		   NEXT LINE
	  LEA PCMSG,A4
	  JSR PDATA		   PRINT "PC="
	  MOVE.L (A0)+,D4	   GET IT
	  JSR OUT8HS		   PRINT REGISTER
	  LEA SRMSG,A4
	  JSR PDATA		   PRINT "SR="
	  MOVE.W (A0)+,D4	   GET IT
	  MOVE.W D4,D0		   SAVE IT
	  MOVE.W D4,D2		   SAVE IT
	  JSR OUT4HS		   PRINT REGISTER
	  MOVE.B #$3D,D4
	  JSR OUTEEE		   PRINT EQUALS
	  LEA SRLETR,A0 	   POINT TO LETTER TABLE
	  MOVE.B #5,D1		   DO FIRST FIVE LETTERS
	  BSR.S SRLOOP		   PRINT LETTERS
	  MOVE.W D2,D4		   GET INTERRUPT MASK
	  LSR.W #8,D4		   INTO RIGHT BYTE
	  AND.B #$07,D4 	   INTERRUPT ONLY
	  ADD.B #$30,D4 	   CVT TO ASCII
	  JSR OUTEEE		   PRINT IT
	  LSL.W #3,D0		   SKIP THE INTERRUPT BITS
	  MOVE.B #8,D1		   DO LAST 8 BITS
	  BSR.S SRLOOP		   PRINT LETTERS
	  LEA USMSG,A4
	  JSR PDATA		   PRINT "US="
	  MOVE.L USERSP,D4	   GET IT
	  JSR OUT8HS		   PRINT REGISTER
	  LEA SSMSG,A4
	  JSR PDATA		   PRINT "SS="
	  MOVE.L SYSTSP,D4	   GET IT
	  JSR OUT8HS		   PRINT REGISTER
	  JSR CRLF		   FINISH UP
	  RTS
* LOOP TO PRINT LETTERS FOR SR
SRLOOP	  MOVE.B (A0)+,D4	   GET NEXT LETTER
	  LSL.W #1,D0		   NEXT BIT INTO C
	  BCS.S SRLUSE		   IS 1 SO USE LETTER
	  MOVE.B #$2E,D4	   IS 0 SO SUBSTITUTE PERIOD
SRLUSE	  JSR OUTEEE		   PRINT IT
	  SUB.B #1,D1		   DECREMENT COUNTER
	  BNE.S SRLOOP
	  RTS
SRLETR	  FCC 'TTSM????XNZVC'

********************************************************
* 'ST' - START SINGLE-STEP COMMAND
********************************************************

STRTSS	  LEA FROMST,A4
	  JSR PDATA		   PRINT "FROM "
	  JSR BADDR		   GET ADDRESS
	  TST.L D5
	  BEQ	COMEND		   NG IF ZERO
	  BTST #0,D5
	  BNE	ODDADD		   NG IF ODD ADDRESS
	  LEA WARMST,A0
	  MOVE.L A0,USTACK-4	   PUT RETURN ADDRESS ON STACK
	  MOVE.L A0,SSTACK-4	   PUT RETURN ADDRESS ON STACK
	  LEA USTACK-4,A0
	  MOVE.L A0,USERSP	   INITIALIZE USER SP MEMORY
	  LEA SSTACK-4,A0
	  MOVE.L A0,SYSTSP	   INITIALIZE SYST SP MEMORY
STEPCO	  MOVE.W USERSR,D0	   OLD STATUS REGISTER
	  MOVE.L SYSTSP,A7	   USE HIS SYSTEM SP
* USE 8 IN FOLLOWING INSTRUCTION FOR 68010/68020 >>B<<
	  SUB.L #6,A7		   BUT STEP BACK 6 TO MAKE ROOM
	  MOVE.W D0,(A7)	   PUT USER SR ON STACK
	  MOVE.L D5,2(A7)	   PUT GOTO ADDRESS ON STACK
* USE FOLLOWING INSTRUCTION FOR 68010/68020 >>B<<
*	  CLR.W 6(A7)		   CLEAR 68010/20 FORMAT
	  MOVE.L USERSP,A0
	  MOVE.L A0,USP 	   SET USER STACK POINTER
	  MOVE.L TRACEV+2,A5
	  MOVE.L A5,TRAVEC	   SAVE OLD TRACE VECTOR
	  LEA TRARET,A5 	   !! SHOULD THIS BE JUST TRARET NO (PC)?
	  MOVE.L A5,TRACEV+2	   PUT IN NEW TRACE VECTOR
	  MOVE.L D5,A0		   SAVE GOTO ADDRESS
	  BSR	PRTINS		   PRINT OUT ADDRESS AND INSTR
	  MOVEM.W (A0),D5-D5	   LOOK AT THE NEXT INSTRUCTION
	  CMP.W #$4E73,D5	   IS IT AN RTE???
	  BEQ.S ISRTE		   YES, IT IS AN RTE
* SIMPLE IF IT'S NOT AN RTE
	  MOVE.W (A7),D5	   GET USER SR
	  OR.W #$8000,D5	   TURN ON TRACE BIT
	  MOVE.W D5,(A7)	   AND BACK ON STACK
	  MOVEM.L REGERS,D0-D7/A0-A6 RESTORE REGISTERS
	  RTE			   AND GO TO USER

* THEN COME BACK TO HERE
TRARET	  MOVEM.L D0-D7/A0-A7,REGERS SAVE REGISTERS
	  MOVE.W (A7),D0
	  AND.W #$7FFF,D0	   TURN OFF TRACE BIT
	  MOVE.W D0,USERSR	   SAVE USER STATUS REGISTER
	  MOVE.L 2(A7),USERPC	   AND USER PC
	  MOVE.L USP,A0
	  MOVE.L A0,USERSP	   AND USER STACK POINTER
	  BTST	 #13,D0 	   CHECK S BIT IN SR
	  BEQ.S TRARUS		   S=0 WAS USER MODE
	  MOVE.L REGA7,D0	   S=1 WAS SYSTEM, SO SAVE SYST SP
	  ADD.L #6,D0		   REMOVE SR AND PC
	  MOVE.L D0,SYSTSP
TRARUS	  MOVE.L TRAVEC,A5
	  MOVE.L A5,TRACEV+2	   RESTORE OLD TRACE VECTOR
	  MOVE.W SYSTSR,SR	   RESTORE INTERRUPT LEVEL
	  JSR REGIST		   PRINT REGISTERS
	  JMP NXTCMD

* IF NEXT INSTRUCTION IS AN RTE, WE HAVE TO CARRY TRACE ACROSS
* CHANGE OF STATE

ISRTE	  MOVE.L USERSP,A5	   USER'S STACK POINTER
	  MOVE.W (A5),D0	   GET SR HE'S RETURNING
	  OR.W #$8000,D0	   SET THAT TRACE BIT
	  MOVE.W D0,(A5)	   RETURN IT
	  MOVEM.L REGERS,D0-D7/A0-A6 RESTORE REGISTERS
	  RTE			   AND FINALLY GO TO USER

* ROUTINE TO PRINT OUT INSTRUCTION POINTED TO BY A0

PRTINS	  JSR CRLF		   NEXT LINE
	  MOVE.L A0,D4		   GOTO ADDRESS
	  SWAP D4
	  BSR	OUT4H		   PRINT IT W/O TRAILING SPACE
	  SWAP D4
	  BSR	OUT4H
	  MOVE.B #$3A,D4
	  JSR OUTEEE		   PRINT :
	  MOVE.B #$20,D4
	  JSR OUTEEE		   PRINT SPACE
	  MOVE.W (A0),D4
	  JSR OUT4HS		   PRINT OP CODE
	  RTS

********************************************************
* 'SS' COMMAND - SINGLE STEP AFTER BREAKPOINT
********************************************************

STEP	  MOVE.L USERPC,D5	   WHERE TO GO
	  BRA	STEPCO		   AND CONTINUE AS IN ST

********************************************************
* 'CO' COMMAND - CONTINUE AFTER A BREAKPOINT
********************************************************

CONT	  MOVE.L USERPC,D5	   WHERE TO GO
	  MOVE.W USERSR,D0	   OLD STATUS REGISTER
	  MOVE.L SYSTSP,A7	   USE HIS SYSTEM SP
* USE 8 IN FOLLOWING INSTRUCTION FOR 68010/68020 >>B<<
	  SUB.L #6,A7		   BUT STEP BACK 6 TO MAKE ROOM
	  MOVE.W D0,(A7)	   PUT USER SR ON STACK
	  MOVE.L D5,2(A7)	   PUT GOTO ADDRESS ON STACK
* USE FOLLOWING INSTRUCTION FOR 68010/68020 >>B<<
*	  CLR.W 6(A7)		   CLEAR 68010/20 FORMAT
	  MOVE.L USERSP,A0
	  MOVE.L A0,USP 	   SET USER STACK POINTER
	  MOVEM.L REGERS,D0-D7/A0-A6 RESTORE REGISTERS
	  RTE			   AND GO TO USER

********************************************************
* 'MC' - MEMORY COMPARISON ROUTINE
********************************************************

COMPAR	  LEA P1MSG,A4
	  JSR PDATA		   PRINT 'PROGRAM 1: '
	  JSR FROMTO		   GET PROGRAM 1 START AND END ADDR.
	  JSR CRLF
	  LEA P2MSG,A4
	  JSR PDATA		   PRINT 'PROGRAM 2: FROM '
	  JSR BADDR		   GET PROGRAM 2 START ADDR.
	  MOVE.L BEGA,A0	   PROG 1 START
	  MOVE.L ENDA,A1	   PROG 1 END
	  ADD.L #1,A1		   POINT PAST IT
	  MOVE.L D5,A2		   PROG 2 START
	  JSR CRLF		   JSR CRLF
	  MOVE.B #3,D0		   INITIALIZE LINE COUNTER
MCLOOP	  MOVE.B (A0)+,D7	   GET NEXT BYTE FROM PGM 1
	  CMP.B (A2)+,D7	   COMPARE WITH PGM 2
	  BEQ.S INCR		   IF SAME, SEE IF DONE
* DIFFERENT BYTES, SO PRINT
	  SUB.B #1,D0		   DECREMENT LINE COUNTER
	  BNE.S MCCONT		   IF ROOM ON LINE, CONTINUE
	  MOVE.B #2,D0		   OTHERWISE RESET
	  JSR CRLF
MCCONT	  JSR OUTS
	  JSR OUTS		   PRINT TWO SPACES
	  MOVE.L A0,D4
	  SUB.L #1,D4
	  JSR OUT8HS		   PRINT ADDRESS 1
	  MOVE.B -1(A0),D4
	  JSR OUT2HS		   PRINT DATA 1
	  MOVE.L A2,D4
	  SUB.L #1,D4
	  JSR OUT8HS		   PRINT ADDRESS 2
	  MOVE.B -1(A2),D4
	  JSR OUT2HS		   PRINT DATA 2
INCR	  CMP.L A0,A1		   DONE?
	  BNE.S MCLOOP
	  RTS			   FINISH UP

********************************************************
* 'HE' - HELP COMMAND
********************************************************

HELP	  JSR CRLF
	  LEA HLPMSG,A4
	  JSR PSTRNG		   PRINT HELP TEXT
	  RTS
******************************************************
* TRAP PROCESSING
******************************************************

* BUSERR - BUS ERROR

BUSERR	  LEA BUSMSG(PC),A4
	  JSR PSTRNG
	  JMP REPORS

* ADDERR - ADDRESS ERROR

ADDERR	  LEA ADDMSG(PC),A4
	  JSR PSTRNG
	  JMP REPORS

* ILLINS - ILLEGAL INSTRUCTION

ILLINS	  MOVEM.L D0-D7/A0-A7,REGERS SAVE REGISTERS
	  MOVE.W (A7),D0
	  MOVE.W D0,USERSR	   SAVE SR
	  MOVE.L USP,A0
	  MOVE.L A0,USERSP	   SAVE SP
	  MOVE.L 2(A7),A0	   GET USER'S PC
	  MOVE.L A0,USERPC	   SAVE PC
	  BTST	 #13,D0 	   CHECK S BIT IN SR
	  BEQ.S ILLIUS		   S=0 WAS USER MODE
	  MOVE.L REGA7,D0	   S=1 WAS SYSTEM, SO SAVE SYST SP
	  ADD.L #6,D0		   SKIP PAST SR AND PC
	  MOVE.L D0,SYSTSP
ILLIUS	  MOVE.W (A0),D0	   GET OFFENDING INSTRUCTION
	  CMP.W #$4AFC,D0	   CHECK IF A BREAK
	  BEQ.S CHKILL		   MAY BE LEGAL, GO CHECK
REALIL	  LEA ILLMSG(PC),A4
	  JSR PSTRNG
PRTILL	  MOVE.L 2(A7),D4
	  JSR OUT8HS		   PRINT ADDRESS
	  JSR REGIST		   PRINT REGISTERS
	  JMP NXTCMD
CHKILL	  CMP.L BKTAB,A0	   CHECK ADDRESS 1
	  BEQ.S ISBRK		   IT'S A BREAK
	  CMP.L BKTAB+6,A0	   CHECK ADDRESS 2
	  BEQ.S ISBRK		   IT'S A BREAK
	  CMP.L BKTAB+12,A0	   CHECK ADDRESS 3
	  BEQ.S ISBRK		   IT'S A BREAK
	  CMP.L BKTAB+18,A0	   CHECK ADDRESS 4
	  BNE.S REALIL		   DEFINITELY ILLEGAL
ISBRK	  LEA BRKMSG,A4
	  JSR PSTRNG		   PRINT "BREAKPOINT AT "
	  BRA.S PRTILL

* ZERDIV - ZERO DIVIDE

ZERDIV	  LEA ZERMSG(PC),A4
	  JSR PSTRNG
	  JMP REPORN

* CHKINS - CHK INSTRUCTION

CHKINS	  LEA CHKMSG(PC),A4
	  JSR PSTRNG
	  JMP REPORN

* TRAPVI - TRAPV INSTR

TRAPVI	  LEA TVIMSG(PC),A4
	  JSR PSTRNG
	  JMP REPORN

* PRIVIO - PRIVILEGE VIOLATION

PRIVIO	  LEA PRIMSG(PC),A4
	  JSR PSTRNG
	  JMP REPORS

* LN1010 - LINE 1010

LN1010	  LEA L10MSG(PC),A4
	  JSR PSTRNG
	  JMP REPORS

* LN1111 - LINE 1111

LN1111	  LEA L11MSG(PC),A4
	  JSR PSTRNG
	  JMP REPORS

* UNASSI - UNASSIGNED

UNASSI	  LEA UNAMSG(PC),A4
	  JSR PSTRNG
	  JMP WARMST

* FORERR - FORMAT ERROR ON 68010

FORERR	  LEA FORMSG(PC),A4
	  JSR PSTRNG
	  JMP WARMST

* SPURIO - SPURIOUS INTERRUPT

SPURIO	  LEA SPUMSG(PC),A4
	  JSR PSTRNG
	  JMP WARMST

* LVL1IA - LEVEL 1 INTERRUPT AUTOVECTOR

LVL1IA	  LEA LV1MSG(PC),A4
	  JSR PSTRNG
	  JMP WARMST

* LVL2IA - LEVEL 2 INTERRUPT AUTOVECTOR

LVL2IA	  LEA LV2MSG(PC),A4
	  JSR PSTRNG
	  JMP WARMST

* LVL3IA - LEVEL 3 INTERRUPT AUTOVECTOR

LVL3IA	  LEA LV3MSG(PC),A4
	  JSR PSTRNG
	  JMP WARMST

* LVL4IA - LEVEL 4 INTERRUPT AUTOVECTOR

LVL4IA	  LEA LV4MSG(PC),A4
	  JSR PSTRNG
	  JMP WARMST

* LVL5IA - LEVEL 5 INTERRUPT AUTOVECTOR

LVL5IA	  LEA LV5MSG(PC),A4
	  JSR PSTRNG
	  JMP WARMST

* LVL6IA - LEVEL 6 INTERRUPT AUTOVECTOR

LVL6IA	  LEA LV6MSG(PC),A4
	  JSR PSTRNG
	  JMP WARMST

* LVL7IA - LEVEL 7 INTERRUPT AUTOVECTOR

LVL7IA	  LEA LV7MSG(PC),A4
	  JSR PSTRNG
	  JMP WARMST

* TRAP0V - TRAP 0

TRAP0V	  LEA TR0MSG(PC),A4
	  JSR PSTRNG
	  JMP REPORN

* TRAP1V - TRAP 1

TRAP1V	  LEA TR1MSG(PC),A4
	  JSR PSTRNG
	  JMP REPORN

* TRAP2V - TRAP 2

TRAP2V	  LEA TR2MSG(PC),A4
	  JSR PSTRNG
	  JMP REPORN

* TRAP3V - TRAP 3

TRAP3V	  LEA TR3MSG(PC),A4
	  JSR PSTRNG
	  JMP REPORN

* TRAP4V - TRAP 4

TRAP4V	  LEA TR4MSG(PC),A4
	  JSR PSTRNG
	  JMP REPORN

* TRAP5V - TRAP 5

TRAP5V	  LEA TR5MSG(PC),A4
	  JSR PSTRNG
	  JMP REPORN

* TRAP6V - TRAP 6

TRAP6V	  LEA TR6MSG(PC),A4
	  JSR PSTRNG
	  JMP REPORN

* TRAP7V - TRAP 7

TRAP7V	  LEA TR7MSG(PC),A4
	  JSR PSTRNG
	  JMP REPORN

* TRAP8V - TRAP 8

TRAP8V	  LEA TR8MSG(PC),A4
	  JSR PSTRNG
	  JMP REPORN

* TRAP9V - TRAP 9

TRAP9V	  LEA TR9MSG(PC),A4
	  JSR PSTRNG
	  JMP REPORN

* TRAPAV - TRAP 10

TRAPAV	  LEA T10MSG(PC),A4
	  JSR PSTRNG
	  JMP REPORN

* TRAPBV - TRAP 11

TRAPBV	  LEA T11MSG(PC),A4
	  JSR PSTRNG
	  JMP REPORN

* TRAPCV - TRAP 12

TRAPCV	  LEA T12MSG(PC),A4
	  JSR PSTRNG
	  JMP REPORN

* TRAPDV - TRAP 13

TRAPDV	  LEA T13MSG(PC),A4
	  JSR PSTRNG
	  JMP REPORN

* TRAPEV - TRAP 14

TRAPEV	  LEA T14MSG(PC),A4
	  JSR PSTRNG
	  JMP REPORN

* REPORT ADDRESS OF EXCEPTION OCCURRENCE. REPORS ASSUMES
* PUSHED ADDRESS IS THAT OF TRAP, REPORN ASSUMES ADDRESS
* IS THAT OF NEXT INSTRUCTION

REPORS	  MOVE.L 2(A7),D4	   GET EXCEPTION'S PC
REPORT	  JSR OUT8HS		   REPORT IT
	  JMP WARMST

REPORN	  MOVE.L 2(A7),D4	   GET EXCEPTION'S PC
	  SUB.L #2,D4		   FIX IT
	  BRA.S REPORT

*******************************************************
* TEXT STRINGS
*******************************************************

BUSMSG	  DEFB 'BUS ERROR AT ',4
ADDMSG	  DEFB 'ADDRESS ERROR AT ',4
ILLMSG	  DEFB 'ILLEGAL INSTRUCTION AT ',4
ZERMSG	  DEFB 'ZERO DIVIDE AT ',4
CHKMSG	  DEFB 'CHK INSTRUCTION AT ',4
TVIMSG	  DEFB 'TRAPV INSTR AT ',4
PRIMSG	  DEFB 'PRIVILEGE VIOLATION AT ',4
L10MSG	  DEFB 'LINE 1010 AT ',4
L11MSG	  DEFB 'LINE 1111 AT ',4
UNAMSG	  DEFB 'UNASSIGNED',4
FORMSG	  DEFB 'FORMAT ERROR ON 68010',4
SPUMSG	  DEFB 'SPURIOUS INTERRUPT',4
LV1MSG	  DEFB 'LEVEL 1 INTERRUPT AUTOVECTOR',4
LV2MSG	  DEFB 'LEVEL 2 INTERRUPT AUTOVECTOR',4
LV3MSG	  DEFB 'LEVEL 3 INTERRUPT AUTOVECTOR',4
LV4MSG	  DEFB 'LEVEL 4 INTERRUPT AUTOVECTOR',4
LV5MSG	  DEFB 'LEVEL 5 INTERRUPT AUTOVECTOR',4
LV6MSG	  DEFB 'LEVEL 6 INTERRUPT AUTOVECTOR',4
LV7MSG	  DEFB 'LEVEL 7 INTERRUPT AUTOVECTOR',4
TR0MSG	  DEFB 'TRAP 0 AT ',4
TR1MSG	  DEFB 'TRAP 1 AT ',4
TR2MSG	  DEFB 'TRAP 2 AT ',4
TR3MSG	  DEFB 'TRAP 3 AT ',4
TR4MSG	  DEFB 'TRAP 4 AT ',4
TR5MSG	  DEFB 'TRAP 5 AT ',4
TR6MSG	  DEFB 'TRAP 6 AT ',4
TR7MSG	  DEFB 'TRAP 7 AT ',4
TR8MSG	  DEFB 'TRAP 8 AT ',4
TR9MSG	  DEFB 'TRAP 9 AT ',4
T10MSG	  DEFB 'TRAP 10 AT ',4
T11MSG	  DEFB 'TRAP 11 AT ',4
T12MSG	  DEFB 'TRAP 12 AT ',4
T13MSG	  DEFB 'TRAP 13 AT ',4
T14MSG	  DEFB 'TRAP 14 AT ',4
H68MSG	  DEFB 'Superstar Monitor Version 1.0 -- '
	  DEFB '(c) 1988 Applied Computer Technology, Inc.',4
NOCMSG	  DEFB ' DATA DID NOT STORE',4
MEBMSG	  DEFB ' BUS ERROR',4
WHMESG	  DEFB 'REGISTER: ',4
FROMST	  DEFB ' FROM ',4
TOSTR	  DEFB ' TO ',4
MANYST	  DEFB 'HOW MANY BYTES? ',4
WITHST	  DEFB ' WITH? ',4
WHATST	  DEFB 'FIND WHAT? ',4
ESTR	  DEFB ' MEMORY FULL OR DEFECTIVE ',4
ANEMSG	  DEFB 'ADDRESS ERROR - NOT EVEN',4
BRKMSG	  DEFB 'BREAKPOINT ENCOUNTERED AT ',4
OLDSTR	  DEFB 'ENTER OLD ADDRESSES:',4
NEWSTR	  DEFB 'ENTER NEW ADDRESS: ',4
BNSTR	  DEFB ' NUMBER: ',4
REMSG	  DEFB '       0        1        2        3        4'
	  DEFB '        5        6        7',4
DMSG	  DEFB 'D: ',4
AMSG	  DEFB 'A: ',4
PCMSG	  DEFB 'PC=',4
SRMSG	  DEFB '   SR=',4
USMSG	  DEFB '   US=',4
SSMSG	  DEFB '   SS=',4
STMSG	  DEFB 'START FROM '
ADMSG	  DEFB 'ADDRESS: ',4
P1MSG	  DEFB 'REGION 1: ',4
P2MSG	  DEFB '     REGION 2:  FROM ',4
HLPMSG	  DEFB 'AD - ASCII Dump              LO - Load S1-S9 format'
	  DEFB $D,$A
	  DEFB 'AI - ASCII Input             MC - Memory Compare'
	  DEFB $D,$A
	  DEFB 'AO - ASCII Output            ME - Memory Examine'
	  DEFB $D,$A
	  DEFB 'BP - Breakpoint Print        MO - Move memory'
	  DEFB $D,$A
	  DEFB 'BR - Breakpoint set/reset    MS - Memory Store'
	  DEFB $D,$A
	  DEFB 'CO - Continue                MT - Memory Test'
	  DEFB $D,$A
	  DEFB 'CS - CheckSum                RC - Register Change'
	  DEFB $D,$A
	  DEFB 'FI - Find 1-5 bytes          RE - Register Examine'
	  DEFB $D,$A
	  DEFB 'FM - Fill Memory             SS - Single Step'
	  DEFB $D,$A
	  DEFB 'HA - Hex and ASCII dump      ST - Start single-step'
	  DEFB $D,$A
	  DEFB 'HD - Hex memory Dump         TB - Tiny Basic Cold'
	  DEFB $D,$A
	  DEFB 'HE - Help (Prints this)      TW - Tiny Basic Warm'
	  DEFB $D,$A
	  DEFB 'JS - Jump to System program  XM - Xmodem Send & Recieve'
	  DEFB $D,$A
	  DEFB 'JU - Jump to User program    !! - Force reset'
	  DEFB $D,$A,4

**********************************************************
* SYSTEM - DEPENDENT ROUTINES
**********************************************************

**********************************************************
* JUMP TABLE WHICH LEADS US TO ALL OF THE FOLLOWING
* ROUTINES IN HUMBUG
**********************************************************

MEMRD	  JMP MEMRD0		 CHECK ALL OF MEMORY
PARON	  JMP PARON0		 TURN ON PARITY CIRCUITRY
INIPOR	  JMP INIPO0		 INITIALIZE PORTS
INCHEK	  JMP INCHE0		 CHECK INPUT PORT
INCH8	  JMP INCH80		 INPUT 8-BIT CHAR
OUTCHP	  JMP OUTPCH		 OUTPUT PRINTER CHARACTER
OUTCHM	  JMP OUTMCH		 OUTPUT CONSOLE CHARACTER
TBASIC	  JMP BASIC		 JUMP TO TINY BASIC
WBASIC	  JMP BASICW		 JUMP TO TINY BASIC WARM

**********************************************************
* PARITY MEMORY ROUTINES
* NEEDED ONLY IF MEMORY CONTAINS PARITY CIRCUITRY
**********************************************************

MEMRD0	  RTS			   READ AND WRITE ALL OF MEMORY

PARON0	  RTS			   THEN TURN ON PARITY CIRCUITRY

************************
* CONSOLE I/O ROUTINES *
************************

***********************************************************
* EQUATES. THESE ROUTINES USE I/O TO COMMUNICATE WITH AN
* 8051 PROCESSOR ON BOARD ACTING AS UART
***********************************************************

COMIN	EQU	$100004 	READS DATA BITS 0-3 FOR DATA FROM 8051
;				BIT4 IS RRF FLAG AND BIT5 IS TBE FLAG
COMOUT	EQU	$100008 	WRITE ONLY SENDS D0-D3 TO 8051
COMCLR	EQU	$10000C 	CLEARS INPUT PORT RRF FLAG

***********************************************************
* INITIALIZE 8051 CPU HANDSHAKE (ONLY ON POWER UP!!)
***********************************************************


INIPO0	MOVE	D0,COMCLR	CLEAR INPUT PORT
HSH1	MOVE	COMIN,D0	READ INPUT PORT
	BTST	#5,D0		SEE IF OUTPUT PORT READY
	BNE.S	HSH1		IF NOT READY TO SEND THEN BRANCH
	MOVE.B	#5,D0		D0=5
	MOVE	D0,COMOUT	WRITE D0 TO OUTPUT PORT
HSH2	MOVE	COMIN,D0	READ INPUT PORT
	BTST	#5,D0		SEE IF OUTPUT PORT READY
	BNE.S	HSH2		IF NOT READY TO SEND THEN BRANCH
	BTST	#4,D0		SEE IF READY TO RECEIVE A CHAR
	BEQ.S	HSH2		IF NO CHAR THEN BRANCH
	MOVE	D0,COMCLR	IF SO CLEAR INPUT PORT EVERYTHING OK
	RTS			ALL DONE SO RETURN

***********************************************************
* INCHEK - CHECK FOR CHAR FROM 8051
***********************************************************

INCHE0	  MOVEM.L D0,-(A7)	   SAVE D0
	  MOVE	  COMIN,D0	   POINT TO INPUT PORT
	  BTST	  #4,D0 	   CHECK RDRF FLAG
	  MOVEM.L (A7)+,D0	   RESTORE D0
	  RTS			   AND RETURN WITH IT

***********************************************************
* GET 8-BIT CHARACTER FROM 8051
***********************************************************

INCH80	MOVEM.L D0-D1,-(A7)	;SAVE D0 ONTO STACK
INCH8A	MOVE	COMIN,D0	;READ INPUT PORT
	NOP			;DELAY
	NOP			;DELAY
	MOVE	COMIN,D1	;READ INPUT PORT AGAIN
	CMP.B	D0,D1		;SAME AS BEFORE
	BNE.S	INCH8A		;IF NOT READ AGAIN!
	BTST	#4,D0		;CHECK RRF FLAG
	BEQ.S	INCH8A		;WAIT IF NOTHING
	MOVE	D0,COMCLR	;CLEAR INPUT PORT
	SWAP	D0		;SWAP WORDS IN D0
INCH8B	MOVE	COMIN,D0	;READ INPUT PORT
	NOP			;DELAY
	NOP			;DELAY
	MOVE	COMIN,D1	;READ INPUT PORT AGAIN
	CMP.B	D0,D1		;SAME AS BEFORE
	BNE.S	INCH8B		;IF NOT READ AGAIN!
	BTST	#4,D0		;SEE IF CHAR READY
	BEQ.S	INCH8B		;WAIT FOR LOW NIBBLE
	MOVE	D0,COMCLR	;CLEAR INPUT PORT
	MOVE.B	D0,D5		;PUT BYTE INTO D5
	SWAP	D0		;SWAP WORDS IN D0
	ANDI.B	#$0F,D5 	;LEAVE ONLY LOWER NIBBLE
	ROR.B	#4,D0		;PUT HI NIB IN RIGHT PLACE
	ANDI.B	#$F0,D0 	;LEAVE ONLY HI NIBBLE
	OR.B	D0,D5		;OR HI & LOW LEAVE IN D5
	MOVEM.L (A7)+,D0-D1	;RESTORE D0 FROM STACK
	RTS

***********************************************************
* OUTPUT ON PRINTER (PORT P)
***********************************************************

OUTPCH	  RTS			   NOT IMPLIMENTED YET

***********************************************************
* OUTPUT TO 8051 CPU
***********************************************************

OUTMCH	MOVEM.L D0,-(A7)	;SAVE D0 IN STACK
	ROR.B	#4,D4		;PUT HI NIBBLE INTO LOW
OUTMC1	MOVE	COMIN,D0	;READ INPUT PORT
	BTST	#5,D0		;SEE IF OUTPUT PORT READY
	BNE.S	OUTMC1		;IF NOT LOOP
	MOVE	D4,COMOUT	;SEND HI NIBBLE
	ROR.B	#4,D4		;PUT LOW BACK INTO LOW
OUTMC2	MOVE	COMIN,D0	;READ INPUT PORT
	BTST	#5,D0		;SEE IF OUTPUT PORT READY
	BNE.S	OUTMC2		;IF NOT LOOP
	MOVE	D4,COMOUT	;SEND LO NIBBLE
	MOVEM.L (A7)+,D0	;RESTORE D0 FROM STACK
	RTS

********************************************************
* XMODEM ROUTINE
********************************************************

ACK	EQU	$06
NAK	EQU	$15
SOH	EQU	$01
EOT	EQU	$04
CTRLC	EQU	$03

XMSG1	DEFB	'Use (C)pu or (V)ideo ram ?',4
XMSG2	DEFB	'(S)end or (R)ecieve data ?',4
XMSG3	DEFB	'Enter Target Address >',4
XMSG4	DEFB	'Initiate transfer. Ctrl-D Aborts.',4
XMSG5	DEFB	'Double video bytes (Y or N) ?',4
XMSG6	DEFB	'Enter Starting Address >',4
XMSG7	DEFB	'Enter Ending Address >',4


XMODEM	LEA	XMSG1,A4	;ASK IF CPU OR VIDEO RAM
	BSR	PSTRNG
	BSR	INEEE		;GET A CHARACTER
	MOVE.B	#0,-(SP)	;0 MEANS CPU RAM TO BE USED
	CMP.B	#'C',D5         ;IS IT A C?
	BEQ.S	CPURAM
	CMP.B	#'V',D5         ;IS IT A V?
	BNE	XMERR		;IF NOT ERROR
	MOVE.B	#1,(SP) 	;ELSE SET FOR VIDEO RAM
	LEA	XMSG5,A4	;ASK IF WE SHOULD DOUBLE VIDEO BYTES!
	BSR	PSTRNG
	BSR	INEEE		;GET A CHARACTER
	CMP.B	#'N',D5         ;IS IT AN S?
	BEQ	CPURAM		;IF SO GO HANDLE NEXT QUESTION
	CMP.B	#'Y',D5         ;IS IT AN R?
	BNE	XMERR		;IF NOT THEN ERROR
	OR.B	#2,(SP) 	;SET BIT 1 OF STACK BYTE
CPURAM	LEA	XMSG2,A4	;ASK IF SEND OR RECIEVE
	BSR	PSTRNG
	BSR	INEEE		;GET A CHARACTER
	CMP.B	#'S',D5         ;IS IT AN S?
	BEQ	XMSEND		;IF SO GO SEND DATA
	CMP.B	#'R',D5         ;IS IT AN R?
	BNE	XMERR		;IF NOT THEN ERROR
;
XMRECV	LEA	XMSG3,A4	;PROMPT TO ENTER TARGER ADDRESS
	BSR	PSTRNG
	BSR	BADDR		;GET ADDRESS IN D5
	MOVE.L	D5,A0		;SAVE IN A0
	MOVE	#2,$A0000	;SET UP TO READ CMD REG
	MOVE	$A0002,D2	;READ IT
	OR	#$8000,D2	;SET ABORT BIT
	MOVE	D2,$A0002	;SEND TO CMD REG TO CLEAR FIFO'S
	AND	#$7FFF,D2	;CLEAR ABORT BIT
	MOVE	D2,$A0002	;AND SEND TO CMD TO ENABLE CMDS
	MOVE	#1,$A0000	;SETUP TO ACCESS VIDEO FIFO

	LEA	XMSG4,A4	;PROMPT TO ENTER TARGET ADDRESS
	BSR	PSTRNG
	MOVE	#1,D1		;SET UP BLOCK #IN D1
XMR1	MOVE	#NAK,D4
XMR15	BSR	OUTCHM		;SEND NAK
	MOVE	#$FFFF,D0	;DELAY TIME
XMR2	BSR	INCHEK		;REC A CHAR YET
	BEQ	XMR3		;IF NOT BRANCH
	BSR	INCH8		;GET CHARACTER
	CMP.B	#EOT,D5 	;ARE WE DONE
	BEQ	XRDONE		;IF SO EXIT LOOP
	CMP.B	#SOH,D5 	;WAS IT A SOH
	BEQ	XRBEG		;IF SO BEGIN
XMR3	DBRA	D0,XMR2 	;LOOP FOR CHAR
	BRA	XMR1		;IF LOOP FAILED SEND NAK AGAIN
XRBEG	MOVE	#1,D3		;CLEAR CHECKSUM
	BSR	GETX		;GET BLOCK COUNT
	MOVE.B	D5,D2		;SAVE IN D2
	CMP.B	D5,D1		;SAME AS OUR BLOCK COUNT?
	BNE	SKIPDAT 	;IF NOT SKIP THIS BLOCK
	BSR	GETX		;GET COMPLEMENT OF BLOCK COUNT
	ADD.B	D5,D2		;ADD TO D2
	ADD.B	#1,D2		;AND ADD 1
	CMP.B	#0,D2		;IS RESULT EQ TO 0?
	BNE	SKIPDAT 	;IF NOT SKIP THIS BLOCK

	MOVE.L	A0,D5		;PUT ADDRESS INTO D5 FOR PROCESSING
	ASL.L	#3,D5		;SHIFT D5 LEFT BY 3
	MOVE	#$080D,D7	;SEND WPR COMMAND TO VIDEO
	BSR	FIPUT
	MOVE	D5,D7		;SETUP LOW WORD OF VIDEO ADDRESS
	BSR	FIPUT
	SWAP	D5		;SWAP WORDS IN D5
	AND	#$FF,D5 	;LEAVE ONLY LO BYTE
	MOVE	#$080C,D7	;SEND WPR COMMAND TO VIDEO
	BSR	FIPUT
	MOVE	D5,D7		;SETUP LOW WORD OF VIDEO ADDRESS
	BSR	FIPUT

	MOVE	#127,D4 	;LOOP FOR 128 BYTES
XRLOOP	BSR	GETX		;GET A BYTE
	CMP.B	#0,(SP) 	;SEND TO CPU RAM
	BNE	XRVRAM		;IF NOT THEN SEND TO VIDEO
	MOVE.B	D5,(A0)+	;PUT INTO CPU RAM
	BRA	XRL1		;GO CHECK FOR END OF BLOCK

XRVRAM	BTST	#1,(SP) 	;TEST BIT 1 OF STACK BYTE
	BEQ.S	XRVR1		;IF NOT SET HANDLE DIFFERENT
	MOVE	D5,D6		;MOVE TO D6
	AND	#$FF,D5 	;LEAVE ONLY LOW BYTE
	ASL	#8,D6		;MOVE D6 TO HI BYTE OF WORD
	OR	D6,D5		;OR BYTES TOGETHER TO FORM WORD
	ADDA	#1,A0		;ADD 1 TO ADDRESS
	BRA.S	XRVR2

XRVR1	MOVE.L	A0,D2		;GET ADDRESS
	BTST	#0,D2		;IS IT AN EVEN ADDRESS
	BEQ.S	XREVN		;IF SO BRANCH
	ASL	#8,D5		;PUT INTO UPPER BYTE OF WORD
	OR	D6,D5		;OR IN HI BYTE FROM LAST TIME
XRVR2	MOVE	#$4800,D7	;SEND WT COMMAND TO VIDEO
	BSR	FIPUT
	MOVE	D5,D7		;SEND DATA
	BSR	FIPUT
	ADDA	#1,A0		;ADD 1 TO ADDRESS
	BRA.S	XRL1		;DONE

XREVN	AND	#$FF,D5 	;LEAVE ONLY LOW BYTE
	MOVE	D5,D6		;SAVE IN D6 FOR NEXT TIME AROUND
	ADDA	#1,A0		;ADD 1 TO ADDRESS

XRL1	DBRA	D4,XRLOOP	;GET ALL 128 BYTES
	MOVE	D3,D4		;SAVE OUR CHECKSUM IN D4
	BSR	GETX		;GET CHECKSUM FROM SENDER
	CMP.B	D4,D5		;SAME AS OURS?
	BEQ	XROK		;IF SO OK!
	SUBA.L	#128,A0 	;ELSE RESET ADDRESS POINTER
	BRA	XMR1		;GO TRY AGAIN

XROK	ADD	#1,D1		;ADD 1 TO BLOCK #
XRO2	MOVE	#ACK,D4 	;SEND ACK TO SENDER
	BRA	XMR15		;GO DO NEXT BLOCK

XRDONE	MOVE	#ACK,D4 	;SEND LAST ACK
	BSR	OUTCHM		;TO SENDER
	MOVE.B	D0,(SP)+	;RESTORE STACK
	JMP	NXTCMD

SKIPDAT MOVE	#128,D4 	;129 BYTES TO SKIP (INCLUDES CHECKSUM!)
SKP1	BSR	GETX		;GET XMODEM CHAR
	DBRA	D4,SKP1 	;LOOP FOR ALL 129
	BRA	XRO2		;TELL SENDER ALL OK AND TRY AGAIN

XMSEND	LEA	XMSG6,A4	;PROMPT TO ENTER STARTING ADDRESS
	BSR	PSTRNG
	BSR	BADDR		;GET ADDRESS IN D5
	MOVE.L	D5,A0		;SAVE IN A0
	LEA	XMSG7,A4	;PROMPT TO ENTER ENDING ADDRESS
	BSR	PSTRNG
	BSR	BADDR		;GET ADDRESS IN D5
	MOVE.L	D5,A1		;SAVE IN A1
	LEA	XMSG4,A4	;PROMPT TO INITIATE TRANSFER
	BSR	PSTRNG
	MOVE	#2,$A0000	;SET UP TO READ CMD REG
	MOVE	$A0002,D2	;READ IT
	OR	#$8000,D2	;SET ABORT BIT
	MOVE	D2,$A0002	;SEND TO CMD REG TO CLEAR FIFO'S
	AND	#$7FFF,D2	;CLEAR ABORT BIT
	MOVE	D2,$A0002	;AND SEND TO CMD TO ENABLE CMDS
	MOVE	#1,$A0000	;SETUP TO ACCESS VIDEO FIFO
	MOVE	#1,D1		;SET UP BLOCK #IN D1

XMS	BSR	INCHEK		;REC A CHAR YET
	BEQ	XMS		;IF NOT BRANCH
	BSR	INCH8		;GET CHARACTER
	CMP.B	#EOT,D5 	;IS IT AN EOT?
	BEQ	XMERR		;IF SO ABORT!
	CMP.B	#NAK,D5 	;WAS IT AN EOT?
	BEQ	XSBEG		;IF SO BEGIN
	BRA.S	XMS		;ELSE LOOP

XMS1	MOVE	#$FFFF,D0	;DELAY TIME
XMS2	BSR	INCHEK		;REC A CHAR YET
	BEQ	XMS3		;IF NOT BRANCH
	BSR	INCH8		;GET CHARACTER
	CMP.B	#EOT,D5 	;IS IT AN EOT?
	BEQ	XMERR		;IF SO ABORT!
	CMP.B	#NAK,D5 	;WAS LAST BLOCK OK?
	BEQ	XSBEG		;IF NOT RESEND BLOCK
	CMP.B	#ACK,D5 	;WAS IT A OK
	BEQ	XMS4		;IF SO BEGIN NEXT BLOCK
XMS3	DBRA	D0,XMS2 	;LOOP FOR CHAR
	BRA	XSBEG		;IF TIMEOUT RESEND BLOCK!
XMS4	ADDA	#128,A0 	;ADD 128 TO ADDRESS
	ADD	#1,D1		;AND INCREMENT BLOCK COUNT
	CMPA.L	A1,A0		;ARE WE PAST ENDING ADDRESS
	BHI	XSDONE		;IF SO END

XSBEG	MOVE	#0,D3		;CLEAR CHECKSUM
	MOVE	#SOH,D4
	BSR	SENDX		;SEND SOH
	MOVE	D1,D4		;GET BLOCK NUMBER
	BSR	SENDX		;SEND IT
	EOR	#$FF,D4 	;COMPLEMENT BLOCK NUMBER
	BSR	SENDX		;SEND IT
	MOVE.L	A0,A3		;AND ALSO INTO A3
	MOVE.L	A0,D2		;PUT IN D2 FOR PROCESSING

	ASL.L	#3,D2		;SHIFT D2 LEFT BY 3
	MOVE	#$080D,D7	;SEND WPR COMMAND TO VIDEO
	BSR	FIPUT
	MOVE	D2,D7		;SETUP LOW WORD OF VIDEO ADDRESS
	BSR	FIPUT
	SWAP	D2		;SWAP WORDS IN D2
	AND	#$FF,D2 	;LEAVE ONLY LO BYTE
	MOVE	#$080C,D7	;SEND WPR COMMAND TO VIDEO
	BSR	FIPUT
	MOVE	D2,D7		;SETUP LOW WORD OF VIDEO ADDRESS
	BSR	FIPUT

	MOVE	#127,D5 	;LOOP FOR 128 BYTES
XSLOOP	BTST	#0,(SP) 	;GET DATA FROM CPU RAM?
	BNE.S	XSVRAM		;IF NOT HANDLE DIFFERENT
	MOVE.B	(A3)+,D4	;ELSE GET BYTE FROM CPU RAM
	BSR	SENDX		;SEND IT
	BRA	XSL1		;GO SEE IF WE ARE DONE

XSVRAM	MOVE	#$4400,D7	;SEND RD COMMAND TO VIDEO
	BSR	FIPUT
	BSR	FIGET
	MOVE	D7,D4		;GET DATA
	BSR	SENDX		;SEND LOW BYTE
	LSR	#8,D4		;MOVE HI BYTE TO LOW
	BSR	SENDX		;SEND HI BYTE
	SUB	#1,D5		;SUBTRACT 1 FROM D5
XSL1	DBRA	D5,XSLOOP	;LOOP FOR ALL 128 BYTES
	MOVE	D3,D4		;GET CHECKSUM IN D4
	BSR	SENDX		;SEND IT!
	BRA	XMS1		;AND GO DO NEXT BLOCK

XSDONE	MOVE	#EOT,D4 	;SEND EOT
	BSR	OUTCHM		;TO SENDER
	MOVE.B	D0,(SP)+	;RESTORE STACK
	JMP	NXTCMD

XMERR	MOVE.B	D0,(SP)+	;RESTORE STACK
	BRA	COMEND

*
* SEND DATA TO ACRTC FIFO
* DATA IN D7
FIPUT	BTST	#1,$A0000	;IS FIFO FULL?
	BEQ.S	FIPUT		;IF SO WAIT
	MOVE	D7,$A0002	;ELSE SEND DATA
	RTS

*
* GET DATA FROM ACRTC FIFO
* DATA IN D7
FIGET	BTST	#2,$A0000	;DATA IN FIFO?
	BEQ.S	FIGET		;IF NOT WAIT
	MOVE	$A0002,D7	;ELSE GET DATA
	RTS

;
; SEND AN XMODEM BYTE & CALC CHECKSUM IN D3
;
SENDX	ADD.B	D4,D3		;ADD TO CHECKSUM
	BSR	OUTCHM		;SEND IT
	RTS

;
;GET AN XMODEM BYTE RETURN IN D5 & CALC CHECKSUM IN D3
;
GETX	MOVE	#$FFFF,D0	;TIMEOUT COUNT
GETX1	BSR	INCHEK		;REC A CHAR YET
	BEQ.S	GETX2		;IF NOT BRANCH
	BSR	INCH8		;GET CHARACTER
	ADD.B	D5,D3		;ADD TO CHECKSUM
	RTS
GETX2	DBRA	D0,GETX1	;LOOP FOR TIMEOUT
	MOVE	D0,(SP)+	;IF TIMEOUT EXCEEDED RESTORE STACK
	BRA	XMR1		;GOTO XMODEM RECIEVE LOOP

********************************************************
* TINY BASIC LANGUAGE
********************************************************


BASICW	  MOVE.L #TBAS+6,D5	   ADRESS OF TINY BASIC WARM
	  BRA.S  BA1		   GO TO BASIC

BASIC	  MOVE.L #TBAS,D5	   ADDRESS OF TINY BASIC
BA1	  MOVE.L #SSTACK,A7	   INITIALIZE STACK TO SYST AREA
	  LEA WARMST,A0
	  MOVE.L A0,-(A7)	   WARMST ADDR ON STACK
	  MOVE.L D5,-(A7)	   GOTO ADDRESS ON STACK
	  MOVEM.L REGERS,D0-D7/A0-A6 RESET A&D REGISTERS
	  RTS			   GO TO SYST PROGRAM

TBAS	  EQU	*

	  END
